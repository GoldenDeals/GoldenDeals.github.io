# Рвем жопу с C и NASM

**Необходимые инструменты:** 
*   Текстовый редактор (VS Code, Sublime Text, Vim, etc.)
*   Компилятор C (GCC или Clang - **GCC предпочтительнее** для совместимости с примерами `asm`)
*   Ассемблер NASM
*   Линковщик (ld, обычно идет с GCC)
*   Отладчик (GDB - **очень важен!**)
*   Hex-редактор (например, `hexedit`, `ghex`, HxD)
*   Инструменты для анализа бинарных файлов: `readelf`, `objdump` (для ELF), `dumpbin` (для PE)
*   Инструмент трассировки системных вызовов: `strace` (Linux), Process Monitor (Windows)
*   ОС Linux (настоятельно рекомендуется для лучшего соответствия примерам и инструментам) или настроенная среда Windows (WSL2, MinGW/MSYS2).

---

### Глава 1: Основы работы с памятью и представлением данных

**Цель:** Глубоко понять организацию памяти, адресацию, представление различных типов данных на бинарном уровне и их размещение.

1.  **Физическая vs. Виртуальная память:**
    *   **Физическая память (ОЗУ/RAM):** Реальные микросхемы памяти, подключенные к материнской плате. Доступ к ней управляется контроллером памяти. Для программиста напрямую недоступна в современных защищенных ОС.
    *   **[Виртуальная память](https://ru.wikipedia.org/wiki/%D0%92%D0%B8%D1%80%D1%82%D1%83%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C):** Абстракция, предоставляемая ОС и [MMU (Memory Management Unit)](https://ru.wikipedia.org/wiki/Memory_management_unit) процессора каждому процессу. Каждый процесс "видит" свое собственное, линейное **адресное пространство** (например, от 0 до $2^{64}-1$ на 64-битной системе), изолированное от других процессов.
    *   **Преимущества виртуальной памяти:**
        *   Изоляция процессов (один процесс не может повредить память другого).
        *   Возможность использовать больше памяти, чем физически доступно (за счет [свопинга/подкачки](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%B4%D0%BA%D0%B0%D1%87%D0%BA%D0%B0_%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B8%D1%86) на диск).
        *   Гибкое управление памятью (отображение файлов в память, общая память).
        *   Защита памяти (права read/write/execute на уровне страниц).
    *   **Страничная организация:** Виртуальное и физическое пространство делятся на блоки фиксированного размера – **страницы** (обычно 4 KB на x86-64). MMU, используя **таблицы страниц** (управляемые ядром ОС), транслирует виртуальные адреса, используемые программой, в физические адреса ОЗУ.
    *   **В этом курсе мы работаем с *виртуальными адресами*.**

2.  **Адресация и Единицы:**
    *   Минимально адресуемая единица – **байт** (8 бит). Каждый байт в *виртуальном* адресном пространстве имеет уникальный адрес.
    *   Адрес – это просто целое число. На 64-битной системе адрес занимает 64 бита (8 байт). $0x0000'0000'0000'0000$ до $0xFFFF'FFFF'FFFF'FFFF$.
    *   Размеры:
        *   Байт: 8 бит
        *   Слово (Word): 16 бит (2 байта) - исторический термин x86.
        *   Двойное слово (Double Word, Dword): 32 бита (4 байта).
        *   Четверное слово (Quad Word, Qword): 64 бита (8 байт).
    *   **Пример:** Если адрес переменной `int x` равен `0x7fffffffdabc`, то эта 4-байтная переменная занимает адреса `0x7fffffffdabc`, `0x7fffffffdabd`, `0x7fffffffdabe`, `0x7fffffffdabf`.

3.  **Представление целых чисел:**
    *   **Беззнаковые (Unsigned):** Все биты используются для представления величины. Диапазон для N бит: от $0$ до $2^N - 1$.
        *   `unsigned char` (8 бит): $0 .. 255$ (`0x00 .. 0xFF`)
        *   `unsigned short` (16 бит): $0 .. 65535$ (`0x0000 .. 0xFFFF`)
        *   `unsigned int` (32 бита): $0 .. 4294967295$ (`0x00000000 .. 0xFFFFFFFF`)
    *   **Со знаком ([Дополнительный код, Two's Complement](https://ru.wikipedia.org/wiki/%D0%94%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4)):** Стандартное представление. Старший бит используется как знаковый (0 – положительное, 1 – отрицательное). Диапазон для N бит: от $-2^{N-1}$ до $2^{N-1} - 1$.
        *   `signed char` (8 бит): $-128 .. 127$ (`0x80 .. 0x7F`)
        *   `signed short` (16 бит): $-32768 .. 32767$ (`0x8000 .. 0x7FFF`)
        *   `signed int` (32 бита): $-2147483648 .. 2147483647$ (`0x80000000 .. 0x7FFFFFFF`)
        *   **Получение отрицательного числа:** Инвертировать все биты положительного числа и прибавить 1.
            *   Пример (8 бит): Число 5 = `00000101`.
            *   Инверсия: `11111010`.
            *   Прибавить 1: `11111011` – это представление числа -5 в дополнительном коде (`0xFB`).
            *   Проверка: $5 + (-5) = 00000101 + 11111011 = (1)00000000$. Перенос отбрасывается.
    *   **Пример на C:**
      ```c
      #include <stdio.h>
      #include <limits.h> // Для *_MAX, *_MIN

      int main() {
          signed char sc = -5; // 0xFB
          unsigned char uc = 251; // 0xFB

          printf("Signed char: %d (0x%X)\n", sc, (unsigned char)sc);
          printf("Unsigned char: %u (0x%X)\n", uc, uc);

          // Интерпретация одних и тех же битов (0xFB) по-разному
          if ((unsigned char)sc == uc) {
              printf("Binary representations are the same: 0xFB\n");
          }

          printf("Max int: %d (0x%X)\n", INT_MAX, INT_MAX);
          printf("Min int: %d (0x%X)\n", INT_MIN, (unsigned int)INT_MIN); // Приведение к unsigned для корректного hex вывода

          return 0;
      }
      ```

4.  **[Порядок байтов (Endianness)](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D1%80%D1%8F%D0%B4%D0%BE%D0%BA_%D0%B1%D0%B0%D0%B9%D1%82%D0%BE%D0%B2):**
    *   Актуально для типов данных размером > 1 байта (`short`, `int`, `long`, `float`, `double`, указатели).
    *   **Little-endian (LE):** Младший байт по младшему адресу. *Используется x86/x86-64.*
    *   **Big-endian (BE):** Старший байт по младшему адресу.
    *   **Пример:** Число `0x12345678` (тип `int`, 4 байта)
        *   Память (адреса растут слева направо):
            *   LE: `` (Адрес `A`: `78`, Адрес `A+1`: `56`, ...)
            *   BE: `` (Адрес `A`: `12`, Адрес `A+1`: `34`, ...)
    *   **Как проверить на C:**
      ```c
      #include <stdio.h>

      int main() {
          unsigned int num = 0x12345678;
          unsigned char *byte_ptr = (unsigned char *)&num; // Указатель на первый байт числа

          printf("Number: 0x%X\n", num);
          printf("Bytes in memory (starting at address %p):\n", byte_ptr);
          for (size_t i = 0; i < sizeof(num); ++i) {
              printf("  Address %p: 0x%02X\n", byte_ptr + i, byte_ptr[i]);
          }

          if (byte_ptr[0] == 0x78) {
              printf("System is Little-Endian.\n");
          } else if (byte_ptr[0] == 0x12) {
              printf("System is Big-Endian.\n");
          } else {
              printf("Unknown or exotic endianness.\n");
          }
          return 0;
      }
      ```
    *   **Важность:** Критично при обмене бинарными данными между системами с разным порядком байтов (сеть, файлы). Сетевой порядок байтов (Network Byte Order) – это Big-Endian. Функции `htons`, `htonl`, `ntohs`, `ntohl` используются для конвертации.

5.  **[Выравнивание данных (Data Alignment)](https://ru.wikipedia.org/wiki/%D0%92%D1%8B%D1%80%D0%B0%D0%B2%D0%BD%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85):**
    *   Многие процессоры (включая x86) работают эффективнее (или требуют этого для некоторых инструкций), если данные размером $N$ байт расположены в памяти по адресу, кратному $N$ (или некоторой степени двойки, не меньшей $N$).
    *   **Естественное выравнивание:**
        *   `char` (1 байт): может быть по любому адресу.
        *   `short` (2 байта): адрес кратен 2.
        *   `int` (4 байта): адрес кратен 4.
        *   `long long`, `double`, указатели (8 байт на x64): адрес кратен 8.
    *   **Компилятор обеспечивает выравнивание:**
        *   **В структурах:** Компилятор может добавлять неиспользуемые байты (padding) между полями или в конце структуры, чтобы каждое поле имело свое естественное выравнивание, и вся структура имела выравнивание самого "широкого" поля.
        *   **На стеке:** Локальные переменные также выравниваются.
    *   **Пример:**
      ```c
      #include <stdio.h>
      #include <stdalign.h> // Для alignof

      struct Example1 {
          char c1;     // 1 байт
          int i;       // 4 байта
          char c2;     // 1 байт
      }; // Ожидаемый размер без выравнивания: 1+4+1 = 6

      struct Example2 {
          char c1;     // 1 байт
          char c2;     // 1 байт
          int i;       // 4 байта
      }; // Ожидаемый размер без выравнивания: 1+1+4 = 6

      int main() {
          printf("Size of Example1: %zu bytes\n", sizeof(struct Example1));
          printf("Alignment of Example1: %zu bytes\n", alignof(struct Example1));
          // Ожидаемый вывод Example1 (x86-64): Size=12, Alignment=4
          // Структура: [c1] [pad] [pad] [pad] [ i ] [ i ] [ i ] [ i ] [c2] [pad] [pad] [pad]
          // Адреса:    0    1     2     3     4     5     6     7     8    9     10    11
          // Выравнивание 'i' требует адреса кратного 4, поэтому 3 байта padding после c1.
          // Общее выравнивание структуры равно 4 (max(alignof(c1), alignof(i), alignof(c2))).
          // Общий размер должен быть кратен 4, поэтому 3 байта padding в конце.

          printf("Size of Example2: %zu bytes\n", sizeof(struct Example2));
          printf("Alignment of Example2: %zu bytes\n", alignof(struct Example2));
          // Ожидаемый вывод Example2 (x86-64): Size=8, Alignment=4
          // Структура: [c1] [c2] [pad] [pad] [ i ] [ i ] [ i ] [ i ]
          // Адреса:    0    1     2     3     4     5     6     7
          // 'i' требует адреса кратного 4, поэтому 2 байта padding после c2.
          // Общий размер кратен 4.

          return 0;
      }
      ```
    *   **`#pragma pack` / `__attribute__((packed))`:** Директивы для управления выравниванием (обычно для уменьшения размера, но с возможной потерей производительности или даже сбоями на некоторых архитектурах). Использовать с осторожностью!

6.  **Указатели (Pointers) – Глубже:**
    *   **Что это?** Переменная, хранящая *виртуальный адрес* другого объекта в памяти.
    *   **Размер указателя:** Зависит от архитектуры. На 32-битной системе – 4 байта, на 64-битной – 8 байт. `sizeof(void*)` или `sizeof(int*)` покажет размер.
    *   **Типизация указателей:** `int *ptr_i; char *ptr_c;` Тип указателя важен для:
        *   **Разыменования (`*`):** Компилятор знает, сколько байт читать/писать по адресу (`*ptr_i` работает с 4 байтами, `*ptr_c` - с 1).
        *   **Арифметики указателей:** `ptr_i++` увеличивает адрес на `sizeof(int)` (обычно 4), `ptr_c++` увеличивает на `sizeof(char)` (1). Это позволяет легко перемещаться по массивам: `arr[i]` эквивалентно `*(arr + i)`.
    *   **Пример:**
      ```c
      #include <stdio.h>

      int main() {
          int numbers[] = {10, 20, 30, 40}; // Массив из 4 int
          int *ptr = numbers; // Указатель на первый элемент (эквивалентно &numbers[0])

          printf("Address stored in ptr: %p\n", ptr);
          printf("Value at that address (*ptr): %d\n", *ptr); // Разыменование

          ptr++; // Арифметика указателей: сдвиг на sizeof(int)
          printf("\nAfter ptr++:\n");
          printf("Address stored in ptr: %p\n", ptr);
          printf("Value at new address (*ptr): %d\n", *ptr); // Доступ ко второму элементу

          printf("\nAccessing elements using pointer arithmetic:\n");
          for (size_t i = 0; i < sizeof(numbers)/sizeof(numbers[0]); ++i) {
              printf("*(numbers + %zu) = %d (at address %p)\n", i, *(numbers + i), numbers + i);
          }

          // Указатель на char
          char message[] = "Hello";
          char *p_char = message;
          printf("\nCharacters and their addresses:\n");
          while (*p_char != '\0') { // Пока не дошли до нуль-терминатора
              printf("'%c' at address %p\n", *p_char, p_char);
              p_char++; // Сдвиг на sizeof(char) = 1 байт
          }

          return 0;
      }
      ```
    *   **`void *`:** "Универсальный" указатель. Может хранить адрес любого типа данных, но его нельзя разыменовать или применять арифметику без явного приведения к конкретному типу. Часто используется в функциях, работающих с произвольными данными (как `memcpy`, `malloc`).

---

### Глава 2: Первая программа на C. Синтаксис, возможности, компиляция (Углубленно)

**Цель:** Детально разобрать процесс компиляции, основные конструкции C и как они могут выглядеть на уровне ассемблера (обзорно).

1.  **Процесс компиляции GCC – Шаг за Шагом:**
    *   Рассмотрим `hello.c`:
      ```c
      // hello.c
      #include <stdio.h>

      int main(void) { // void указывает, что main не принимает аргументов командной строки
          puts("Hello, C World!"); // puts проще printf для вывода строк
          return 0;
      }
      ```
    *   **Полная команда компиляции и линковки:** `gcc hello.c -o hello`
    *   **Этапы (можно выполнить по отдельности):**
        1.  **Препроцессинг:** Обработка директив (`#include`, `#define`).
            *   Команда: `gcc -E hello.c -o hello.i`
            *   Файл `hello.i` будет большим, т.к. содержит развернутый код из `<stdio.h>` (и других включенных файлов). В конце будет наш `main`. Препроцессор выполняет чисто текстовые операции.
        2.  **Компиляция (в Ассемблер):** Перевод C-кода в ассемблерный код для целевой архитектуры.
            *   Команда: `gcc -S hello.i -o hello.s` (или `gcc -S hello.c -o hello.s`, GCC сам вызовет препроцессор).
            *   Файл `hello.s` содержит ассемблерный код (по умолчанию AT&T синтаксис). Мы его подробно разберем в следующих главах. Увидим метки `main`, инструкции `call puts`, `movl $0, %eax` (для `return 0`), `ret`.
        3.  **Ассемблирование:** Перевод ассемблерного кода в машинный код (объектный файл).
            *   Команда: `gcc -c hello.s -o hello.o` (или `gcc -c hello.c -o hello.o`, GCC вызовет препроцессор и компилятор).
            *   Файл `hello.o` – это [объектный файл](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D1%8B%D0%B9_%D1%84%D0%B0%D0%B9%D0%BB) (в формате ELF на Linux). Он содержит машинный код функции `main`, но адрес функции `puts` еще неизвестен (это внешняя функция из `libc`). Также содержит метаданные: таблицу символов, информацию о релокациях. Посмотреть содержимое можно через `objdump -d hello.o` (дизассемблер), `objdump -t hello.o` (символы).
        4.  **Линковка (Компоновка):** Объединение одного или нескольких объектных файлов и библиотек для создания исполняемого файла. Разрешение внешних ссылок.
            *   Команда: `gcc hello.o -o hello` (GCC вызывает линковщик `ld`).
            *   Линковщик находит реализацию `puts` в стандартной библиотеке C (`libc.so` или `libc.a`), возможно, добавляет стартовый код (`_start`), который инициализирует среду C и вызывает `main`, и создает исполняемый файл `hello`.
            *   Исполняемый файл `hello` также имеет формат ELF (на Linux).
    *   **Флаги компиляции:**
        *   `-o <имя>`: Задать имя выходного файла.
        *   `-c`: Только компилировать и ассемблировать (создать `.o`).
        *   `-S`: Только препроцессинг и компиляция (создать `.s`).
        *   `-E`: Только препроцессинг (вывод на stdout или в файл).
        *   `-g`: Добавить отладочную информацию (для GDB).
        *   `-Wall -Wextra -pedantic`: Включить больше предупреждений компилятора (очень рекомендуется!).
        *   `-O0, -O1, -O2, -O3, -Os`: Уровни оптимизации (влияют на ассемблерный код!). `-O0` - без оптимизации (лучше для начального анализа).

2.  **Базовый синтаксис (с акцентом на низкоуровневые аспекты):**
    *   **Типы данных:** Как обсудили в Главе 1, определяют размер и интерпретацию битов в памяти (`sizeof`, выравнивание).
    *   **Переменные:** Именованные области памяти.
        *   Глобальные: Определены вне функций. Хранятся в секциях `.data` (инициализированные) или `.bss` (неинициализированные) исполняемого файла. Время жизни - вся программа.
        *   Статические (внутри функции): `static int counter = 0;` Хранятся также в `.data` или `.bss`, но видимы только внутри функции. Сохраняют значение между вызовами.
        *   Локальные (автоматические): Определены внутри функции без `static`. Хранятся на **стеке**. Создаются при входе в функцию, уничтожаются при выходе.
    *   **Операторы:** Транслируются в одну или несколько ассемблерных инструкций.
        *   Арифметика: `+` -> `add`, `-` -> `sub`, `*` -> `imul`, `/` -> `idiv`.
        *   Битовые: `&` -> `and`, `|` -> `or`, `^` -> `xor`, `~` -> `not`, `<<` -> `shl`, `>>` -> `shr`/`sar`. Очень эффективны.
        *   Сравнение: `==`, `!=`, `<`, `>` -> `cmp` + условный переход (`je`, `jne`, `jl`, `jg`).
    *   **Управляющие конструкции (трансляция в ассемблер - упрощенно):**
        *   `if (cond) { A; } else { B; }` -> вычисление `cond`, `cmp`, условный переход (например, `jne` на метку `else_block`), код `A`, безусловный переход (`jmp`) на метку `endif`, метка `else_block:`, код `B`, метка `endif:`.
        *   `while (cond) { A; }` -> метка `loop_start:`, вычисление `cond`, `cmp`, условный переход (`jne`) на метку `loop_body`, переход на `loop_end`, метка `loop_body:`, код `A`, переход на `loop_start`, метка `loop_end:`.
        *   `for (init; cond; step) { A; }` -> код `init`, переход на проверку `cond`, метка `loop_body:`, код `A`, код `step`, метка `cond_check:`, вычисление `cond`, `cmp`, условный переход (`jne`) на `loop_body`, выход из цикла.
    *   **Функции:**
        *   Транслируются в блок ассемблерного кода, начинающийся с метки (имя функции) и заканчивающийся инструкцией `ret`.
        *   **Вызов функции:** Инструкция `call имя_функции`. Она помещает адрес *следующей* за `call` инструкции (адрес возврата) на стек и передает управление на метку `имя_функции`.
        *   **Возврат из функции:** Инструкция `ret`. Она снимает адрес возврата со стека и передает управление по этому адресу.
        *   **Передача аргументов и возврат значения:** Регулируется **[Соглашением о вызовах (Calling Convention)](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%B3%D0%BB%D0%B0%D1%88%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%B0)**. Для Linux x86-64 это System V AMD64 ABI: первые 6 целочисленных/указательных аргументов передаются через регистры `RDI`, `RSI`, `RDX`, `RCX`, `R8`, `R9`. Результат возвращается в `RAX` (или `RAX:RDX` для 128-битных). Аргументы с плавающей точкой - через `XMM0-XMM7`. Остальные аргументы - через стек. Мы подробно разберем это при анализе ассемблерного кода.

3.  **Пример для анализа (сохраним как `control.c`):**
    ```c
    // control.c
    int conditional_check(int a, int b) {
        if (a > b) {
            return a * 2;
        } else {
            return b + 1;
        }
    }

    int loop_sum(int count) {
        int sum = 0;
        for (int i = 0; i < count; i++) {
            sum += i;
        }
        return sum;
    }

    // Заглушка main, чтобы можно было скомпилировать
    int main() {
       volatile int res1 = conditional_check(5, 10); // volatile, чтобы компилятор не выкинул вызов
       volatile int res2 = loop_sum(5);
       return res1 + res2; // Просто чтобы использовать результаты
    }
    ```
    *   **Задание:** Скомпилируйте `control.c` с флагом `-S -O0 -mno-red-zone` (`-masm=intel` опционально) и посмотрите на ассемблерный код функций `conditional_check` и `loop_sum`. Попытайтесь узнать инструкции `cmp`, условные (`jg`, `jle`) и безусловные (`jmp`) переходы, инструкции для арифметики (`imul`, `add`, `mov`), а также пролог/эпилог функций (`push rbp`, `mov rbp, rsp`, `pop rbp`, `ret`). (Детальный разбор будет в Главе 6).

---

### Глава 3: Препроцессор C (Углубленно)

**Цель:** Глубоко понять задачи и механизмы работы препроцессора, его директивы и потенциальные проблемы макросов.

1.  **Задачи препроцессора:**
    *   Обработка текста исходного файла *до* основной компиляции.
    *   Не понимает синтаксис C (кроме контекста директив).
    *   Основные действия:
        *   **Удаление комментариев:** `// ...` и `/* ... */` заменяются пробелами.
        *   **Включение файлов (`#include`):** Текстовая вставка содержимого указанного файла.
        *   **Макроподстановка (`#define`):** Замена идентификаторов (макросов) на их определения.
        *   **Условная компиляция (`#if`, `#ifdef`, ...):** Включение/исключение фрагментов кода на основе условий.
        *   **Обработка других директив (`#pragma`, `#error`, `#warning`, `#line`).**

2.  **`#include` – Подробнее:**
    *   `#include <file.h>`: Поиск `file.h` в системных каталогах, указанных компилятору (обычно `/usr/include`, `/usr/local/include`, и пути, специфичные для компилятора). Используется для стандартных библиотек.
    *   `#include "file.h"`: Поиск `file.h` сначала в каталоге, где находится текущий исходный файл, а затем в системных каталогах. Используется для собственных заголовочных файлов проекта.
    *   **Проблема двойного включения:** Если файл `A.h` включает `B.h`, а файл `C.c` включает и `A.h`, и `B.h`, то содержимое `B.h` будет вставлено дважды, что приведет к ошибкам переопределения (типов, функций и т.д.).
    *   **Решение – Защита от включения (Include Guards):** Стандартный идиоматический прием.
      ```c
      // my_header.h
      #ifndef MY_HEADER_H_INCLUDED // 1. Проверить, не определен ли уникальный макрос
      #define MY_HEADER_H_INCLUDED // 2. Если нет, определить его

      // --- Содержимое заголовочного файла ---
      struct MyData {
          int value;
          char name[32];
      };

      int process_data(struct MyData *data);
      // --- Конец содержимого ---

      #endif // MY_HEADER_H_INCLUDED // 3. Конец условного блока
      ```
      При первой вставке `MY_HEADER_H_INCLUDED` не определен, условие `#ifndef` истинно, макрос определяется, и содержимое файла включается. При последующих попытках включить этот же файл в той же единице компиляции (`.c` файле), макрос уже будет определен, условие `#ifndef` ложно, и все содержимое между `#ifndef` и `#endif` пропускается препроцессором.
    *   **Альтернатива:** `#pragma once` - не стандартная, но поддерживаемая многими компиляторами директива, которая делает то же самое, что и include guards, но без необходимости придумывать уникальные имена макросов.

3.  **`#define` – Макросы:**
    *   **Объектные макросы (Константы):** Простая текстовая подстановка.
      ```c
      #define BUFFER_SIZE 1024
      #define PI 3.14159
      char buffer[BUFFER_SIZE];
      double area = PI * r * r;
      // После препроцессора:
      // char buffer[1024];
      // double area = 3.14159 * r * r;
      ```      *Предпочтительнее использовать `const` переменные или `enum` в C для типизированных констант.*
    *   **Функциональные макросы (Function-like):** С параметрами.
      ```c
      #define MAX(a, b) ((a) > (b) ? (a) : (b))
      #define SQUARE(x) ((x)*(x))

      int larger = MAX(x + 1, y);
      int sq = SQUARE(i++); // ОПАСНО!
      // После препроцессора:
      // int larger = ((x + 1) > (y) ? (x + 1) : (y));
      // int sq = ((i++)*(i++)); // i инкрементируется ДВАЖДЫ! Побочный эффект.
      ```
    *   **Важность скобок:**
        *   В определении макроса: `SQUARE(x)` как `((x)*(x))`. Если написать `x*x`, то `SQUARE(a + b)` раскроется в `a + b*a + b`, что неверно.
        *   В использовании параметров: `MAX(a, b)` как `((a) > (b) ? (a) : (b))`. Если написать `(a > b ? a : b)`, то `MAX(x & mask, y)` может раскрыться с неверным приоритетом операций.
    *   **Потенциальные проблемы макросов:**
        *   **Многократное вычисление аргументов с побочными эффектами:** Как в примере `SQUARE(i++)`.
        *   **Проблемы с приоритетом операций:** Решается обилием скобок.
        *   **Отсутствие проверки типов:** Макрос примет любой тип, что может привести к неожиданному поведению или ошибкам компиляции в месте использования.
        *   **Сложность отладки:** Ошибки компилятора указывают на раскрытый код макроса, а не на его вызов. В отладчике нельзя "войти" в макрос.
        *   **Загрязнение пространства имен:** Макросы глобальны (в пределах единицы компиляции после их определения).
        *   **Негигиеничные макросы:** Могут случайно использовать локальные переменные или конфликтовать с именами в окружающем коде.
    *   **Строкификация (`#`):** Превращает аргумент макроса в строковый литерал.
      ```c
      #define PRINT_VAR(var) printf(#var " = %d\n", var)
      int count = 10;
      PRINT_VAR(count); // Раскроется в: printf("count" " = %d\n", count);
                       // Строки "count" и " = %d\n" конкатенируются компилятором.
      ```
    *   **Конкатенация токенов (`##`):** Склеивает два токена в один.
      ```c
      #define MAKE_FUNC_NAME(type, index) type##_function_##index
      void int_function_1(void) { /* ... */ }
      void float_function_2(void) { /* ... */ }
      // ...
      MAKE_FUNC_NAME(int, 1)(); // Вызовет int_function_1()
      ```
    *   **Вывод:** Макросы - мощный, но опасный инструмент. В современном C/C++ часто есть лучшие альтернативы (inline функции, const/constexpr, шаблоны C++). Но для условной компиляции и некоторых идиом они незаменимы.

4.  **Условная компиляция:**
    *   Позволяет включать или исключать код на этапе препроцессинга.
    *   `#if выражение_константное`: Вычисляется препроцессором. `defined(МАКРОС)` проверяет, определен ли макрос.
    *   `#ifdef МАКРОС`: Эквивалентно `#if defined(МАКРОС)`.
    *   `#ifndef МАКРОС`: Эквивалентно `#if !defined(МАКРОС)`.
    *   `#elif выражение`: `else if`.
    *   `#else`: Альтернативный блок.
    *   `#endif`: Завершение блока условной компиляции.
    *   **Применения:**
        *   Защита от двойного включения (уже рассмотрели).
        *   Платформенно-зависимый код:
          ```c
          #ifdef _WIN32 // Макрос, обычно определяемый компиляторами под Windows
              #include <windows.h>
              // Windows-специфичный код
          #elif defined(__linux__) // Макрос для Linux
              #include <unistd.h>
              // Linux-специфичный код
          #else
              #warning "Unsupported platform"
          #endif
          ```
        *   Включение/выключение отладочного кода:
          ```c
          #ifdef DEBUG
              #define LOG(...) fprintf(stderr, __VA_ARGS__)
          #else
              #define LOG(...) // Пустой макрос, вызовы исчезнут
          #endif

          // ...
          LOG("Processing item %d\n", item_id);
          ```
          Компиляция с флагом `-DDEBUG` определит макрос `DEBUG`.

5.  **Другие директивы:**
    *   `#undef МАКРОС`: Отменяет определение макроса.
    *   `#error Сообщение об ошибке`: Прекращает компиляцию с выводом сообщения.
    *   `#warning Сообщение`: Выводит предупреждение компиляции.
    *   `#pragma директива`: Предоставляет компилятору дополнительную информацию (зависит от компилятора). Примеры: `#pragma once`, `#pragma pack(...)`.
    *   `#line номер "файл"`: Изменяет внутренние счетчики номера строки и имени файла компилятора (используется генераторами кода).

6.  **Просмотр результата:**
    *   `gcc -E source.c` - выведет результат препроцессинга в stdout.
    *   Анализ этого вывода помогает понять, как раскрываются макросы и включаются файлы, и отлаживать проблемы препроцессора.

---

### Глава 4: Работа компилятора, перевод в ассемблер (Углубленно)

**Цель:** Детально исследовать процесс трансформации C-кода в ассемблер, понять влияние оптимизаций и базовые принципы генерации кода для различных конструкций C.

1.  **Роль компилятора (Фаза после препроцессора):**
    *   **Лексический анализ (Токенизация):** Разбиение текста программы на лексемы (токены): ключевые слова (`int`, `while`), идентификаторы (`my_var`), константы (`123`, `"hello"`), операторы (`+`, `=`), знаки пунктуации (`;`, `{`).
    *   **Синтаксический анализ (Парсинг):** Проверка соответствия последовательности токенов грамматике языка C. Построение **Абстрактного Синтаксического Дерева (AST)**, представляющего структуру программы.
    *   **Семантический анализ:** Проверка смысловой корректности. Проверка типов (`int x = "hello";` - ошибка), области видимости переменных, правильности вызовов функций.
    *   **Генерация промежуточного представления (IR - Intermediate Representation):** Преобразование AST в более низкоуровневое, но еще не машинно-зависимое представление (например, трехадресный код, SSA - Static Single Assignment form). На этом этапе выполняются многие машинно-независимые оптимизации.
    *   **Оптимизация:** Применение различных техник для улучшения кода (скорость, размер). Примеры:
        *   **Свертка констант (Constant Folding):** `x = 2 + 3;` -> `x = 5;`
        *   **Распространение констант (Constant Propagation):** `x = 10; y = x + 5;` -> `x = 10; y = 15;`
        *   **Удаление мертвого кода (Dead Code Elimination):** Удаление кода, результат которого не используется или который недостижим.
        *   **Устранение общих подвыражений (Common Subexpression Elimination):** `a = b * c + d; e = b * c * f;` -> `temp = b * c; a = temp + d; e = temp * f;`
        *   **Развертывание циклов (Loop Unrolling):** Замена цикла на последовательность копий его тела для уменьшения накладных расходов на проверку условия и инкремент.
        *   **Встраивание функций (Function Inlining):** Замена вызова функции ее телом.
        *   **Оптимизации, зависимые от машины:** Использование специфических инструкций, лучшее распределение регистров.
    *   **Генерация кода (Code Generation):** Перевод оптимизированного IR в ассемблерный код для целевой архитектуры (x86-64, ARM и т.д.) с учетом соглашений о вызовах (ABI). Это включает **выбор инструкций** и **распределение регистров**.
    *   **Вывод ассемблерного кода (`.s` файл).**

2.  **Генерация ассемблерного кода (GCC):**
    *   Флаг: `-S`.
    *   Синтаксис:
        *   По умолчанию AT&T: `movl %eax, %ebx` (источник, приемник), регистры с `%`, константы с `$`, адресация `смещение(%база, %индекс, масштаб)`.
        *   Intel: `mov ebx, eax` (приемник, источник), регистры без префикса, константы как есть, адресация `[база + индекс*масштаб + смещение]`. Для включения: `-masm=intel`. **Мы будем использовать Intel синтаксис в примерах анализа.**
    *   Рассмотрим пример `control.c` из Главы 2. Компилируем без оптимизации:
        `gcc -S -O0 -mno-red-zone -masm=intel control.c -o control_O0.s`
        *   `-mno-red-zone`: Отключает "красную зону" (128 байт ниже RSP, которые можно использовать без изменения RSP в листовых функциях по ABI) для более простого и явного управления стеком в примерах.

3.  **Анализ `control_O0.s` (ключевые моменты):**
    *   **Файл `.s` содержит:**
        *   **Директивы ассемблера (`.`):** `.file`, `.intel_syntax noprefix`, `.text`, `.globl`, `.type`, `.size`, `.section .rodata`, `.string`, `.align`, `.cfi_*` (информация для отладки и раскрутки стека).
        *   **Метки (`:`):** `conditional_check:`, `loop_sum:`, `main:`, `.L1:`, `.L2:` (локальные метки, генерируемые компилятором).
        *   **Инструкции:** `mov`, `cmp`, `jle`, `jmp`, `add`, `imul`, `ret`, `push`, `pop`, `sub`, `call`.
    *   **Функция `conditional_check` (упрощенно):**
      ```assembly
      conditional_check:
          push    rbp                ; Пролог: сохранить старый RBP
          mov     rbp, rsp           ; Установить новый RBP
          mov     DWORD PTR [rbp-4], edi ; Сохранить 1-й аргумент (a) из EDI на стек [rbp-4]
          mov     DWORD PTR [rbp-8], esi ; Сохранить 2-й аргумент (b) из ESI на стек [rbp-8]
          mov     eax, DWORD PTR [rbp-4] ; Загрузить 'a' в EAX
          cmp     eax, DWORD PTR [rbp-8] ; Сравнить 'a' (в EAX) с 'b' (в памяти)
          jle     .L2                ; Перейти к .L2 если a <= b (else ветка)
      ; if (a > b) ветка:
          mov     eax, DWORD PTR [rbp-4] ; Загрузить 'a' в EAX
          sal     eax, 1             ; Умножить на 2 (сдвиг влево на 1 бит), результат в EAX
          jmp     .L3                ; Перейти к концу функции
      .L2: ; else ветка:
          mov     eax, DWORD PTR [rbp-8] ; Загрузить 'b' в EAX
          add     eax, 1             ; Прибавить 1, результат в EAX
      .L3: ; Конец if/else (перед эпилогом)
          pop     rbp                ; Эпилог: восстановить RBP
          ret                        ; Вернуть управление, результат в EAX
      ```
      *Наблюдения:* Аргументы (пришли в EDI, ESI) сохраняются на стек. Условие `if` транслируется в `cmp` и условный переход `jle` (Jump if Less or Equal - переход, если условие `a > b` *не* выполнено). Возвращаемое значение помещается в `EAX` перед `ret`.
    *   **Функция `loop_sum` (упрощенно):**
      ```assembly
      loop_sum:
          push    rbp
          mov     rbp, rsp
          sub     rsp, 16            ; Выделить место на стеке для sum и i
          mov     DWORD PTR [rbp-12], edi ; Сохранить 'count' из EDI на стек [rbp-12]
          mov     DWORD PTR [rbp-4], 0  ; Инициализация sum = 0 [rbp-4]
          mov     DWORD PTR [rbp-8], 0  ; Инициализация i = 0 [rbp-8]
          jmp     .L5                ; Перейти к проверке условия цикла
      .L6: ; Тело цикла
          mov     eax, DWORD PTR [rbp-8] ; Загрузить 'i'
          add     DWORD PTR [rbp-4], eax ; Прибавить 'i' к 'sum'
          add     DWORD PTR [rbp-8], 1  ; Инкремент 'i'
      .L5: ; Проверка условия цикла
          mov     eax, DWORD PTR [rbp-8] ; Загрузить 'i'
          cmp     eax, DWORD PTR [rbp-12] ; Сравнить 'i' с 'count'
          jl      .L6                ; Перейти в тело цикла если i < count
      ; После цикла
          mov     eax, DWORD PTR [rbp-4] ; Загрузить 'sum' в EAX для возврата
          leave                      ; Эквивалент: mov rsp, rbp; pop rbp
          ret
      ```
      *Наблюдения:* Локальные переменные `sum` и `i` размещены на стеке (`[rbp-4]`, `[rbp-8]`). Цикл `for` превратился в комбинацию `jmp`, `cmp` и условного перехода `jl` (Jump if Less). Инициализация и шаг цикла - отдельные блоки инструкций. `leave` - удобная инструкция для эпилога.

4.  **Влияние оптимизации:**
    *   Скомпилируем с `-O2`: `gcc -S -O2 -mno-red-zone -masm=intel control.c -o control_O2.s`
    *   **Анализ `control_O2.s` (ожидаемые изменения):**
        *   **`conditional_check`:** Код станет короче. Компилятор может избежать сохранения аргументов на стек, работая прямо с регистрами `EDI` и `ESI`. Вместо `sal eax, 1` может использовать `lea eax, [rdi+rdi]` (если `a` осталось в `rdi`). Логика `if/else` может быть реализована с помощью инструкций условной пересылки (`cmov`). Пролог/эпилог могут исчезнуть, если функция простая (leaf function).
        *   **`loop_sum`:** Очень вероятно, что компилятор *узнает* цикл, вычисляющий сумму арифметической прогрессии $0 + 1 + ... + (count-1)$. Он может **полностью убрать цикл** и заменить его формулой: `sum = count * (count - 1) / 2`. Ассемблерный код будет содержать несколько инструкций для вычисления по этой формуле (`imul`, `sub`, `sar` или `idiv`), без каких-либо циклов!
        *   **`main`:** Так как результаты присваиваются `volatile` переменным, компилятор, скорее всего, оставит вызовы функций. Но если бы `volatile` не было, он мог бы вычислить результаты `conditional_check(5, 10)` и `loop_sum(5)` во время компиляции и подставить константы.
    *   **Вывод:** Оптимизация может *радикально* изменить ассемблерный код, делая его зачастую не похожим на исходный C-код. Анализ неоптимизированного кода (`-O0`) проще для понимания базовой трансляции C -> Asm. Анализ оптимизированного кода (`-O2`, `-O3`) показывает, как компилятор пытается улучшить производительность.

5.  **Роль Ассемблера (Программы `as` или `nasm`):**
    *   Принимает `.s` файл.
    *   Переводит мнемоники инструкций (`mov`, `add`, `jmp`) и операнды в их двоичное представление (машинный код, опкоды).
    *   Вычисляет адреса меток (или оставляет информацию для линковщика, если метка внешняя).
    *   Обрабатывает директивы ассемблера (например, `.data`, `.string` для размещения данных).
    *   Создает **объектный файл (`.o`)**, содержащий:
        *   Машинный код (в секции `.text`).
        *   Данные (в секциях `.data`, `.rodata`).
        *   Информацию о неинициализированных данных (`.bss`).
        *   **Таблицу символов:** Имена определенных и неопределенных (внешних) функций и глобальных переменных.
        *   **Информацию о релокациях:** Указывает линковщику, какие адреса в коде или данных нужно исправить после того, как все объектные файлы будут объединены в одно адресное пространство. Например, адрес вызова внешней функции `puts` в `hello.o` нуждается в релокации.


### Глава 5: Введение в NASM (Углубленно)

**Цель:** Освоить основы синтаксиса NASM, понять базовую архитектуру x86-64 с точки зрения программиста на ассемблере, научиться писать, ассемблировать, линковать и отлаживать простейшие программы с использованием системных вызовов и стандартной библиотеки C.

1.  **Что такое NASM?**
    *   **Роль:** NASM (Netwide Assembler) – это программа-ассемблер. Её задача – переводить человекочитаемый **ассемблерный код** (текст с мнемониками инструкций, директивами, метками) в **машинный код** (последовательности байт, понятные процессору), упакованный в объектный файл.
    *   **Синтаксис Intel vs AT&T:**
        *   NASM использует **синтаксис Intel**, который широко распространен в документации Intel и Microsoft. Ключевые отличия от AT&T (используемого GCC/GAS по умолчанию):
            | Характеристика         | Intel (NASM)                  | AT&T (GAS)                         |
            | :--------------------- | :---------------------------- | :--------------------------------- |
            | Порядок операндов    | `инструкция приемник, источник` | `инструкция %источник, %приемник`  |
            | Префиксы регистров   | Нет (`rax`, `ebx`)             | `%` (`%rax`, `%ebx`)               |
            | Префиксы констант    | Нет (`123`, `0xFF`)            | `$` (`$123`, `$0xFF`)              |
            | Размер операндов     | Явно или по регистру (`mov eax, dword [var]`) | Суффикс инструкции (`movl $1, %eax`) |
            | Косвенная адресация | `[база + индекс*масштаб + смещ]` | `смещ(%база, %индекс, масштаб)`     |
        *   Пример: `mov eax, [my_var + ecx*4]` (Intel) vs `movl my_var(,%ecx,4), %eax` (AT&T). Intel часто считается более интуитивным.
    *   **Кросс-платформенность и форматы вывода:** NASM может работать на Linux, Windows, macOS и генерировать объектные файлы для разных систем:
        *   `-f elf64`: Формат ELF 64-bit (стандарт для Linux x86-64).
        *   `-f win64`: Формат PE 64-bit (для Windows x86-64).
        *   `-f macho64`: Формат Mach-O 64-bit (для macOS x86-64).
        *   `-f bin`: "Плоский" бинарный файл (чистый машинный код без метаданных, для загрузчиков, прошивок).
    *   **Установка:**
        *   Linux (Debian/Ubuntu): `sudo apt update && sudo apt install nasm`
        *   Linux (Fedora): `sudo dnf install nasm`
        *   macOS (Homebrew): `brew install nasm`
        *   Windows: Скачать с [официального сайта](https://www.nasm.us/) или установить через менеджер пакетов (Chocolatey: `choco install nasm`).

2.  **Основы архитектуры x86-64 (Взгляд программиста):**
    *   **Регистры – Сверхбыстрая память внутри ЦП:**
        *   **Регистры Общего Назначения (GPRs):** Основные рабочие лошадки. 16 регистров по 64 бита.
            *   `RAX`: **Аккумулятор**. Традиционно используется для возврата значений функций, в некоторых инструкциях умножения/деления.
            *   `RBX`: **Базовый регистр**. Часто используется для хранения указателя на базу данных (Callee-saved).
            *   `RCX`: **Счетчик**. Используется инструкциями цикла (`loop`), для сдвигов, как 4-й аргумент функции (ABI).
            *   `RDX`: **Данные**. Используется в паре с `RAX` для 128-битных результатов умножения/деления, как 3-й аргумент функции.
            *   `RSI`: **Индекс Источника (Source Index)**. Используется в строковых инструкциях как указатель на источник, как 2-й аргумент функции.
            *   `RDI`: **Индекс Приемника (Destination Index)**. Используется в строковых инструкциях как указатель на приемник, как 1-й аргумент функции.
            *   `RBP`: **Указатель Базы Стекового Кадра (Base Pointer)**. Традиционно указывает на базу текущего стекового кадра. Позволяет обращаться к локальным переменным и аргументам с фиксированным смещением. (Callee-saved).
            *   `RSP`: **Указатель Вершины Стека (Stack Pointer)**. Всегда указывает на последний использованный (самый младший адрес) элемент на стеке. Изменяется инструкциями `push`, `pop`, `call`, `ret`, `sub rsp, ...`.
            *   `R8` - `R15`: Дополнительные GPR, добавленные в x86-64. `R8` - 5-й аргумент, `R9` - 6-й аргумент функции.
        *   **Доступ к частям регистров:** Можно обращаться к младшим частям GPR:
            ![x86-64 Register Naming](https://upload.wikimedia.org/wikipedia/commons/thumb/4/4f/X86_64_register_set.svg/600px-X86_64_register_set.svg.png)
            *   64 бита: `RAX, RBX, ..., R15`
            *   Младшие 32 бита: `EAX, EBX, ..., R15D` (Запись в 32-битную часть **обнуляет** старшие 32 бита 64-битного регистра!)
            *   Младшие 16 бит: `AX, BX, CX, DX, SI, DI, BP, SP, R8W, ..., R15W`
            *   Младшие 8 бит: `AL, BL, CL, DL, SIL, DIL, BPL, SPL, R8B, ..., R15B`
            *   Биты 8-15 из AX/BX/CX/DX: `AH, BH, CH, DH` (Их использование часто менее эффективно на современных ЦП).
            *   Пример: `mov eax, 0xFFFFFFFF` -> `RAX` станет `0x00000000FFFFFFFF`. `mov al, 0x11` -> изменит только младший байт `RAX`, `EAX`, `AX`. `mov ah, 0x22` -> изменит только байт `AH` регистра `AX`. **Указатель Инструкций (`RIP` - Instruction Pointer):** Содержит виртуальный адрес *следующей* инструкции, которая будет выполнена. Не может быть изменен напрямую большинством инструкций. Изменяется неявно при выполнении каждой инструкции, а также инструкциями передачи управления (`jmp`, `call`, `ret`, условные переходы). В x86-64 часто используется *RIP-относительная адресация* для доступа к глобальным данным и вызова функций в позиционно-независимом коде (PIC/PIE). Пример: `mov eax, [rel my_global_var]` или `call [rel function_ptr]`. **Регистр Флагов (`RFLAGS`):** 64-битный регистр, содержащий биты состояния процессора. Наиболее важные для нас флаги (устанавливаются арифметическими, логическими инструкциями, `cmp`, `test`): `ZF` (**Zero Flag**): Устанавливается в 1, если результат последней операции равен нулю; иначе 0. (Используется `jz`, `je`, `jnz`, `jne`).
            *   `CF` (**Carry Flag**): Устанавливается в 1, если была беззнаковая (!) операция переноса (сложение) или заема (вычитание) из старшего бита; иначе 0. (Используется `jc`, `jnc`, `adc`, `sbb`).
            *   `SF` (**Sign Flag**): Устанавливается в 1, если старший бит результата (знаковый бит) равен 1 (отрицательное число в доп. коде); иначе 0. (Используется `js`, `jns`).
            *   `OF` (**Overflow Flag**): Устанавливается в 1, если произошла знаковая (!) операция переполнения (результат не помещается в знаковый диапазон); иначе 0. (Используется `jo`, `jno`).
            *   Пример: `sub eax, eax` (EAX становится 0) -> ZF=1. `cmp eax, 5` -> флаги устанавливаются как если бы выполнилось `eax - 5`, но `eax` не меняется. `test rcx, rcx` (логическое И `rcx` с `rcx`) -> ZF=1 если `rcx` был 0, иначе ZF=0.
    *   **Инструкции (Обзор категорий):**
        *   **Пересылка данных:** `mov`, `push` (на стек), `pop` (со стека), `lea` (Load Effective Address - вычисляет адрес и помещает его в регистр, не обращаясь к памяти).
        *   **Арифметика:** `add`, `sub`, `inc` (инкремент), `dec` (декремент), `neg` (смена знака), `imul` (знаковое умножение), `idiv` (знаковое деление), `mul`, `div` (беззнаковые).
        *   **Логика:** `and`, `or`, `xor`, `not` (битовое НЕ), `test` (логическое И без сохранения результата, только флаги), `shl`/`sal` (сдвиг влево), `shr` (логический сдвиг вправо), `sar` (арифметический сдвиг вправо).
        *   **Управление потоком:** `jmp` (безусловный переход), `call` (вызов подпрограммы), `ret` (возврат), условные переходы (`je`, `jne`, `jg`, `jl`, `jge`, `jle`, `js`, `jns`, `jc`, `jnc`, `jo`, `jno`, `jz`, `jnz` - основаны на флагах).
        *   **Строковые:** `movsb/w/d/q`, `cmpsb/w/d/q`, `scasb/w/d/q`, `lodsb/w/d/q`, `stosb/w/d/q` (оперируют памятью по адресам `RSI`/`RDI`, управляются `RCX` и префиксом `rep`).

3.  **Синтаксис NASM – Детали:**
    *   **Регистр и инструкции:** Обычно не чувствительны к регистру (`mov rax, 1` эквивалентно `MOV RAX, 1`), но метки и символы (`my_label`, `printf`) - **чувствительны**. Лучшая практика: использовать нижний регистр для инструкций и регистров.
    *   **Операнды:**
        *   Регистр: `rax`, `edi`, `sp`, `r15w`, `dl`.
        *   Непосредственное значение (Immediate): `100`, `0xDEADBEEF`, `0b10101010`, `'A'`, `"String"`. Строки в данных, не как немедленный операнд для `mov` (кроме 64 бит).
        *   Операнд памяти: `[адрес_или_выражение]`.
            *   `[my_label]`: Адрес метки `my_label`.
            *   `[rax]`: Адрес, хранящийся в `rax`.
            *   `[rbp - 8]`: Адрес (содержимое `rbp` минус 8).
            *   `[rsi + rcx*4 + 20h]`: Сложный адрес (база+индекс*масштаб+смещение). Масштаб может быть 1, 2, 4, 8.
        *   **Спецификаторы размера:** NASM часто угадывает размер по регистру (`mov rcx, rax` - 64 бита). Но для памяти и констант лучше указывать явно: `byte`, `word`, `dword`, `qword`.
            *   `mov byte [my_var], 5` ; Записать 1 байт
            *   `inc word [counter]` ; Инкрементировать 2-байтовое значение
            *   `add [data_ptr], dword 10` ; Прибавить 10 к 4-байтному значению
            *   `mov rax, qword 1` ; Загрузить 64-битную константу
    *   **Метки:** `my_function:`, `loop_start:`. Определяют символическое имя для адреса.
        *   **Локальные метки:** Начинаются с точки (`.loop`, `.done`). Их область видимости - между двумя нелокальными метками. Удобны для циклов и `if` внутри одной функции, чтобы не придумывать уникальные глобальные имена.
    *   **Директивы (Команды для NASM):**
        *   **Секции:**
            *   `section .text` или `segment .text`: Код (инструкции). Обычно имеет права Read+Execute.
            *   `section .data` или `segment .data`: Инициализированные данные. Read+Write.
            *   `section .rodata`: Инициализированные данные только для чтения (константы, строки). Read-Only.
            *   `section .bss` или `segment .bss`: Неинициализированные данные. Read+Write. Занимает место только в памяти, не в файле (кроме размера). ОС обнуляет эту секцию при загрузке.
        *   **Определение данных:**
            *   `db 0x12, 'H', 'e', 'l', 'l', 'o', 0` ; Определить байты (число, символы, нуль-терминатор)
            *   `dw 0x1234, -1` ; Определить слова (16 бит)
            *   `dd 3.14159` ; Определить Dword (32 бита, можно и float константы)
            *   `dq 0x11223344AABBCCDD` ; Определить Qword (64 бита)
            *   `times 10 db 0` ; Повторить `db 0` десять раз
        *   **Резервирование данных (в `.bss`):**
            *   `buffer: resb 1024` ; Зарезервировать 1024 байта
            *   `matrix: resd 16` ; Зарезервировать 16 * 4 = 64 байта
        *   **Символы:**
            *   `global my_function`: Сделать метку `my_function` видимой для линковщика (чтобы ее можно было вызвать из другого файла или чтобы она стала точкой входа).
            *   `extern printf`: Сообщить NASM, что `printf` - это внешний символ, который будет разрешен линковщиком (найден в другой библиотеке, как `libc`).
        *   **Константы ассемблера:**
            *   `BUFFER_SIZE equ 1024`: Присвоить символу `BUFFER_SIZE` значение `1024`. NASM просто подставит `1024` везде, где встретит `BUFFER_SIZE`.
            *   `$`: Адрес начала текущей строки инструкции/данных.
            *   `$$`: Адрес начала текущей секции.
            *   `msglen equ $ - message`: Классический способ вычислить длину строки `message` во время ассемблирования. `$ ` - это адрес *сразу после* строки `message`, `message` - адрес ее начала.
    *   **Комментарии:** Начинаются с `;` и идут до конца строки.

4.  **"Hello, World!" через Linux Syscalls (Детальный разбор `hello_syscall.asm`):**
    ```nasm
    ; hello_syscall.asm - Prints "Hello, NASM Syscall!" and exits.
    ; Assemble: nasm -f elf64 hello_syscall.asm -o hello_syscall.o
    ; Link:     ld hello_syscall.o -o hello_syscall
    ; Run:      ./hello_syscall

    section .data ; Начало секции инициализированных данных
        message db "Hello, NASM Syscall!", 0xA ; db = Define Byte. Определяем байты строки + символ новой строки (LF = 0xA).
                ; Метка 'message' получает адрес первого байта ('H').
        msglen  equ $ - message             ; equ = Equate. Вычисляем константу msglen.
                ; $ здесь - адрес ПОСЛЕ последнего байта строки (0xA).
                ; message - адрес начала строки. Разница - это длина.

    section .text ; Начало секции кода
        global _start                   ; Делаем метку _start видимой для линковщика.
                ; 'ld' по умолчанию ищет _start как точку входа.

    _start:         ; Метка - точка входа в программу
        ; --- Системный вызов write (номер 1) ---
        ; Смотрим таблицу системных вызовов Linux x86-64 (например, /usr/include/asm/unistd_64.h):
        ; #define __NR_write 1
        ; Соглашение о вызовах syscall:
        ; RAX = номер системного вызова
        ; RDI, RSI, RDX, R10, R8, R9 = аргументы (до 6)
        ; Прототип C: ssize_t write(int fd, const void *buf, size_t count);

        mov rax, 1          ; Помещаем 1 (номер sys_write) в RAX.
        mov rdi, 1          ; Помещаем 1 (файловый дескриптор stdout) в RDI (первый аргумент).
        mov rsi, message    ; Помещаем адрес строки 'message' (из секции .data) в RSI (второй аргумент).
        mov rdx, msglen     ; Помещаем длину строки 'msglen' (константа) в RDX (третий аргумент).
        syscall             ; Выполняем инструкцию syscall. Процессор переходит в режим ядра,
                ; ядро выполняет write, затем возвращает управление сюда.

        ; Результат write (кол-во записанных байт или -errno) будет в RAX. Мы его игнорируем.

        ; --- Системный вызов exit (номер 60) ---
        ; #define __NR_exit 60
        ; Прототип C: void exit(int status);

        mov rax, 60         ; Помещаем 60 (номер sys_exit) в RAX.
        mov rdi, 0          ; Помещаем 0 (код возврата - успех) в RDI (первый аргумент).
        syscall             ; Вызываем ядро. Программа завершается, ядро не возвращает управление.
    ```
    *   **Сборка и запуск:**
        *   `nasm -f elf64 hello_syscall.asm -o hello_syscall.o`
            *   `-f elf64`: Говорит NASM создать объектный файл в формате ELF 64-bit.
        *   `ld hello_syscall.o -o hello_syscall`
            *   `ld`: Стандартный линковщик GNU. Собирает из объектного файла `hello_syscall.o` исполняемый файл `hello_syscall`. Находит точку входа `_start` (так как она объявлена `global`).
        *   `./hello_syscall`
            *   Оболочка запускает программу. Ядро Linux загружает ELF-файл, создает процесс, отображает секции `.text` и `.data` в память и передает управление на адрес `_start`.
    *   **Проверка:**
        *   `echo $?`: Посмотреть код завершения последней команды. Должен быть `0`.
        *   `strace ./hello_syscall`: Утилита `strace` перехватывает и показывает системные вызовы программы. Вывод будет примерно таким:
          ```
          execve("./hello_syscall", ["./hello_syscall"], 0x7ffc... /* 55 vars */) = 0
          write(1, "Hello, NASM Syscall!\n", 21)   = 21
          exit(0)                                 = ?
          +++ exited with 0 +++
          ```
          Видим успешный вызов `write` (на stdout (fd=1), строка, длина 21) и `exit` с кодом 0.

5.  **"Hello, World!" через `printf` из libc (Детальный разбор `hello_printf.asm`):**
    *   **Почему `main` и `gcc`?** Когда мы хотим использовать функции из стандартной библиотеки C (как `printf`), нам нужен не только код самой функции, но и *код инициализации C runtime*. Этот код (обычно в файлах `crt1.o`, `crti.o`, `crtn.o`) предоставляет настоящую точку входа `_start`, которая подготавливает окружение для C (например, обрабатывает аргументы командной строки `argc`, `argv`, инициализирует `stdio`) и затем вызывает функцию `main`, которую мы должны определить. После возврата из `main`, код C runtime вызывает `exit()` с кодом возврата из `main` (который мы помещаем в `RAX`). Компилятор `gcc`, используемый для линковки, автоматически добавляет эти `crt*` файлы и саму библиотеку `libc.so`.
    *   **System V AMD64 ABI (Ключевые моменты для вызова функций):**
        *   Первые 6 целочисленных/указательных аргументов: `RDI`, `RSI`, `RDX`, `RCX`, `R8`, `R9`.
        *   Аргументы с плавающей точкой: `XMM0` - `XMM7`.
        *   Возвращаемое значение (целое/указатель): `RAX`.
        *   Для вариативных функций (как `printf`): `RAX` должен содержать количество аргументов, переданных через регистры `XMM`. Если используются только целочисленные/указательные аргументы, `RAX = 0`.
        *   Стек должен быть выровнен по 16 байт *перед* инструкцией `call`. (Начало `main` после `call` из libc уже выровнено, но если мы делаем `push` или `sub rsp` не кратно 16, нужно корректировать).
        *   Регистры `RBX`, `RBP`, `R12`-`R15` считаются *callee-saved*: если наша функция их изменяет, она должна сохранить их старые значения (обычно на стеке) и восстановить перед возвратом (`ret`). Остальные (`RAX`, `RCX`, `RDX`, `RSI`, `RDI`, `R8`-`R11`, `RFLAGS`, `XMM`) - *caller-saved*: вызывающая функция должна сама позаботиться об их сохранении, если они ей нужны после `call`.
    ```nasm
    ; hello_printf.asm - Prints using printf from libc.
    ; Assemble: nasm -f elf64 hello_printf.asm -o hello_printf.o
    ; Link:     gcc hello_printf.o -o hello_printf
    ; Run:      ./hello_printf

    section .rodata ; Используем .rodata для константных строк (Read-Only Data)
        format_string db "Hello from printf! Number: %d, String: %s", 0xA, 0 ; %d для int, %s для строки. Null-terminated (0).
        other_string  db "NASM", 0                                       ; Строка для подстановки в %s. Null-terminated.

    section .text
        global main             ; Точка входа для C runtime - 'main'. Экспортируем символ.
        extern printf           ; Сообщаем NASM, что printf - внешний символ (из libc).

    main:
        ; --- Пролог функции ---
        ; Сохраняем RBP (callee-saved) и устанавливаем базу стекового кадра.
        ; Это стандартный пролог, генерируемый GCC (даже с -O0), полезен для отладки.
        push rbp                ; Сохранить старое значение RBP на стек
        mov  rbp, rsp           ; Установить RBP на текущую вершину стека (начало нашего кадра)
        ; Стек выровнен по 16 байт ДО вызова main. push rbp сдвигает rsp на 8 байт.
        ; Если бы мы выделяли место (sub rsp, X), нужно было бы учитывать выравнивание.

        ; --- Вызов printf ---
        ; printf(format_string, 123, other_string);
        ; Аргументы по ABI:
        ; 1: RDI <- адрес format_string
        ; 2: RSI <- значение 123
        ; 3: RDX <- адрес other_string
        ; RAX <- 0 (т.к. нет аргументов в XMM регистрах)

        mov rdi, format_string  ; Загружаем адрес форматной строки (из .rodata) в RDI.
        mov esi, 123            ; Загружаем константу 123 в RSI (используем ESI, т.к. int 32-битный, обнулит старшую часть RSI).
        mov rdx, other_string   ; Загружаем адрес 'other_string' (из .rodata) в RDX.
        mov eax, 0              ; Устанавливаем RAX в 0 для printf (т.к. нет XMM аргументов). Обнуляет старшую часть RAX.
        call printf             ; Вызываем функцию printf. Адрес возврата (след. инструкция после call) помещается на стек.
                                ; Управление передается коду printf в libc.

        ; printf вернет управление сюда. Результат (кол-во символов) будет в RAX. Мы его игнорируем.

        ; --- Эпилог функции ---
        ; Восстанавливаем стек и регистры в состояние до вызова main (кроме RAX).
        ; mov rax, 0              ; Устанавливаем возвращаемое значение main (0 = успех) в RAX.
        ; leave                 ; Эквивалентно: mov rsp, rbp (освобождает локальные переменные, если были); pop rbp (восстанавливает RBP вызывающей функции).
        ; ret                   ; Снимает адрес возврата со стека и переходит по нему (возврат в C runtime).

        mov eax, 0              ; Установить код возврата 0.
        pop rbp                 ; Восстановить RBP (альтернатива leave, если не было локальных переменных).
        ret                     ; Вернуться в C runtime.
    ```
    *   **Сборка и запуск:**
        *   `nasm -f elf64 hello_printf.asm -o hello_printf.o`
        *   `gcc hello_printf.o -o hello_printf`
            *   GCC видит, что `printf` не определен в `hello_printf.o`, находит его в `libc.so` (стандартная библиотека C, подключается по умолчанию), добавляет `crt` файлы, разрешает все символы и создает исполняемый файл `hello_printf`.
            *   **PIE (Position Independent Executable):** Современные GCC по умолчанию создают PIE. Если `ld` ругается на релокации (особенно при линковке `.o` от NASM с кодом C), может понадобиться флаг `-no-pie` при линковке: `gcc -no-pie hello_printf.o -o hello_printf`.
        *   `./hello_printf`
    *   **Проверка:**
        *   Вывод на консоль должен быть: `Hello from printf! Number: 123, String: NASM`
        *   `echo $?`: Должен быть `0`.
        *   `strace ./hello_printf`: Покажет гораздо больше системных вызовов, чем `hello_syscall`. `printf` может буферизовать вывод, C runtime выполняет инициализацию/финализацию, динамический загрузчик (`ld-linux.so`) отображает `libc.so` в память. Мы увидим `execve`, `brk`, `mmap`, `access`, `openat`, `read`, `write` (наш вывод), `close`, `exit_group`. Это иллюстрирует разницу между прямыми syscalls и использованием библиотечных функций.

6.  **Отладка NASM с GDB (Используем `hello_printf`):**
    *   **Сборка с отладочной информацией:**
        *   `nasm -f elf64 -g -F dwarf hello_printf.asm -o hello_printf.o`
            *   `-g`: Говорит NASM включить базовую отладочную информацию (метки).
            *   `-F dwarf`: Указывает формат отладочной информации (DWARF - стандарт для Unix-like систем).
        *   `gcc -g hello_printf.o -o hello_printf`
            *   `-g`: Говорит GCC сохранить отладочную информацию из `.o` файла при линковке и добавить свою (например, для кода C runtime).
    *   **Запуск GDB:** `gdb ./hello_printf`
    *   **Сессия GDB:**
        ```bash
        (gdb) b main             # Установить точку останова на метке main
        Breakpoint 1 at 0x...: file hello_printf.asm, line 14.
        (gdb) run                # Запустить программу
        Starting program: /path/to/hello_printf

        Breakpoint 1, main () at hello_printf.asm:14
        14          push    rbp         ; Save caller's base pointer
        (gdb) layout asm         # Показать окно с ассемблерным кодом
        (gdb) layout regs        # Показать окно с регистрами
        # Окна появятся (или используйте Ctrl+X, 2 для переключения в режим TUI)
        (gdb) si                 # Step Instruction: выполнить push rbp
        15          mov     rbp, rsp    ; Set our base pointer
        # Наблюдаем за изменением RSP и памяти на его старом значении в окне регистров/памяти
        (gdb) si
        ...                      # Выполняем инструкции до mov rdi, format_string
        24          mov     rdi, format_string  ; 1st argument
        (gdb) si
        25          mov     esi, 123            ; 2nd argument (immediate value)
        (gdb) info registers rdi # Посмотреть значение RDI - должен быть адрес строки
        rdi            0x...      # GDB может показать и имя метки: 0x... <format_string>
        (gdb) x/s $rdi           # Examine string at address in RDI
        0x... <format_string>:	"Hello from printf! Number: %d, String: %s\n"
        (gdb) si                 # Выполнить mov esi, 123
        26          mov     rdx, other_string   ; 3rd argument
        (gdb) info registers rsi
        rsi            0x7b       # 123 в hex
        (gdb) si                 # Выполнить mov rdx, other_string
        27          mov     eax, 0              ; 0 floating point arguments in XMM registers
        (gdb) x/s $rdx           # Посмотреть строку по адресу в RDX
        0x... <other_string>:	"NASM"
        (gdb) si                 # Выполнить mov eax, 0
        28          call   printf             ; Call the C library function printf
        (gdb) ni                 # Next Instruction: выполнить call printf, НЕ заходя внутрь libc
        # Программа выведет строку на консоль
        34          mov    eax,0x0              ; Установить код возврата 0.
        (gdb) info registers rax # Посмотреть возвращаемое значение printf (количество символов)
        rax            0x...      # Должно быть 36 (или около того)
        (gdb) c                  # Continue: продолжить выполнение до конца
        Continuing.
        [Inferior 1 (process ...) exited normally]
        (gdb) q                  # Выйти из GDB
        ```
    *   Отладка позволяет пошагово увидеть, как выполняются инструкции, как меняются регистры и память, как передаются аргументы – это ключ к пониманию низкоуровневого кода.


### Глава 6: Анализ программы на C, скомпилированной в ассемблер (Углубленно)

**Цель:** Детально сопоставить основные конструкции языка C с ассемблерным кодом x86-64 (Intel синтаксис), сгенерированным GCC, как с оптимизацией, так и без нее. Научиться "читать" ассемблерный листинг и понимать решения, принятые компилятором.

1.  **Подготовка:**
    *   **Пример кода (сохраним как `analysis_target.c`):**
        ```c
        #include <stdio.h>
        #include <stdlib.h> // для malloc/free

        // Глобальная переменная
        long global_counter = 0;

        // Структура
        typedef struct {
            int id;
            char name[16];
            double value;
        } Item;

        // Функция с указателями и доступом к структуре
        void process_item(Item *item_ptr, int factor) {
            if (item_ptr != NULL) {
                item_ptr->id += factor;
                item_ptr->value *= factor;
                global_counter++; // Доступ к глобальной переменной
            }
        }

        // Функция с циклом и массивом
        long sum_array(int *array, size_t size) {
            long sum = 0;
            for (size_t i = 0; i < size; ++i) {
                if (array[i] > 10) { // Условие внутри цикла
                    sum += array[i];
                }
            }
            return sum;
        }

        int main() {
            // Локальные переменные, выделение памяти
            int local_var = 5;
            int numbers[] = {5, 15, 8, 25, 12};
            Item *my_item = malloc(sizeof(Item));

            if (my_item == NULL) {
                return 1; // Ошибка выделения памяти
            }

            // Инициализация структуры
            my_item->id = 101;
            snprintf(my_item->name, sizeof(my_item->name), "TestItem");
            my_item->value = 99.5;

            // Вызовы функций
            process_item(my_item, local_var);
            long total = sum_array(numbers, sizeof(numbers) / sizeof(numbers[0]));

            printf("Item ID: %d, Value: %.2f\n", my_item->id, my_item->value);
            printf("Array Sum (>10): %ld\n", total);
            printf("Global Counter: %ld\n", global_counter);

            free(my_item); // Освобождение памяти
            return 0;
        }
        ```
    *   **Компиляция (без оптимизации):**
        `gcc -S -O0 -mno-red-zone -masm=intel -g analysis_target.c -o analysis_target_O0.s`
        *   `-g`: Добавляем отладочную информацию, это поможет `objdump` и GDB сопоставить строки C и ассемблера.
    *   **Компиляция (с оптимизацией):**
        `gcc -S -O2 -mno-red-zone -masm=intel -g analysis_target.c -o analysis_target_O2.s`

2.  **Анализ `analysis_target_O0.s` (Неоптимизированный код):**
    *   **Инструменты:** Текстовый редактор для просмотра `.s` файла, `objdump -dS analysis_target` (после сборки с `-g`) для просмотра ассемблера вместе с C кодом. GDB для пошагового выполнения.
    *   **Глобальная переменная `global_counter`:**
        *   В секции `.bss` (т.к. инициализирована нулем неявно или явно): `.comm global_counter, 8, 8` (Имя, Размер 8 байт, Выравнивание 8 байт).
        *   В `process_item`: `mov rax, QWORD PTR global_counter[rip]` (Чтение значения, RIP-относительная адресация), `add rax, 1` (Инкремент), `mov QWORD PTR global_counter[rip], rax` (Запись обратно). `[rip]` означает, что адрес вычисляется относительно текущего значения регистра `RIP`. Это стандарт для позиционно-независимого кода (PIE/PIC).
    *   **Структура `Item`:** Компилятор знает смещения полей от начала структуры. `sizeof(Item)` будет рассчитано с учетом выравнивания (вероятно, 1 + (3 байта паддинг) + 16 + 8 = 28 байт -> округляется до кратного 8 (выравнивание `double`) = 32 байта).
        *   `id`: смещение 0
        *   `name`: смещение 4 (из-за паддинга после `id`, если `int` требует выравнивания 4)
        *   `value`: смещение 20 (4 + 16) -> скорее 24 из-за выравнивания `double` (8 байт).
    *   **Функция `process_item`:**
        *   **Пролог:** `push rbp`, `mov rbp, rsp`.
        *   **Сохранение аргументов:** `mov QWORD PTR [rbp-8], rdi` (сохранить `item_ptr` из RDI), `mov DWORD PTR [rbp-12], esi` (сохранить `factor` из ESI).
        *   **Проверка `item_ptr != NULL`:** `cmp QWORD PTR [rbp-8], 0`, `je .L_SKIP` (перейти, если равно нулю).
        *   **Доступ к полям структуры (`item_ptr->id += factor`):**
            *   `mov rax, QWORD PTR [rbp-8]` ; Загрузить адрес структуры (item_ptr) в RAX
            *   `mov edx, DWORD PTR [rbp-12]` ; Загрузить factor в EDX
            *   `add DWORD PTR [rax], edx` ; Прибавить factor к полю по смещению 0 от адреса в RAX (т.е., к `item_ptr->id`). Смещение `+0` опущено.
        *   **Доступ к полю `value` (`item_ptr->value *= factor`):** (Обратите внимание на использование XMM регистров для `double`)
            *   `mov rax, QWORD PTR [rbp-8]` ; Адрес структуры в RAX
            *   `pxor xmm0, xmm0` ; Обнулить XMM0 (стандартная практика перед преобразованием)
            *   `cvtsi2sd xmm0, DWORD PTR [rbp-12]` ; Преобразовать `factor` (int) из памяти в `double` в XMM0.
            *   `movsd xmm1, QWORD PTR [rax+24]` ; Загрузить `item_ptr->value` (смещение 24) в XMM1 (`movsd` - move scalar double).
            *   `mulsd xmm1, xmm0` ; Умножить XMM1 на XMM0 (value * factor).
            *   `movsd QWORD PTR [rax+24], xmm1` ; Сохранить результат обратно в `item_ptr->value`.
        *   **Инкремент `global_counter`:** Рассмотрен выше.
        *   `.L_SKIP:` Метка для пропуска кода при `item_ptr == NULL`.
        *   **Эпилог:** `nop` (часто вставляется для выравнивания), `pop rbp`, `ret`.
    *   **Функция `sum_array`:**
        *   **Пролог, сохранение аргументов:** `[rbp-24]` для `array` (указатель, RDI), `[rbp-32]` для `size` (RSI).
        *   **Локальные переменные:** `sum` на стеке `[rbp-8] = 0`, `i` на стеке `[rbp-16] = 0`.
        *   **Цикл `for`:**
            *   Начало: `jmp .L_COND_CHECK`.
            *   `.L_LOOP_BODY:`
                *   **Доступ к `array[i]`:**
                    *   `mov rax, QWORD PTR [rbp-16]` ; Загрузить `i` в RAX (тип `size_t` - 64 бита).
                    *   `mov rdx, QWORD PTR [rbp-24]` ; Загрузить адрес `array` в RDX.
                    *   `movsxd rcx, DWORD PTR [rdx + rax*4]` ; Загрузить `int` из `array + i*4` в RCX, со знаковым расширением до 64 бит. `movsxd` - Move with Sign-Extension Doubleword.
                *   **Сравнение `array[i] > 10`:** `cmp ecx, 10`, `jle .L_SKIP_ADD`.
                *   **Сложение `sum += array[i]`:** `add QWORD PTR [rbp-8], rcx`.
            *   `.L_SKIP_ADD:`
            *   **Инкремент `i`:** `add QWORD PTR [rbp-16], 1`.
            *   `.L_COND_CHECK:`
                *   `mov rax, QWORD PTR [rbp-16]` ; Загрузить `i`.
                *   `cmp rax, QWORD PTR [rbp-32]` ; Сравнить `i` с `size`.
                *   `jb .L_LOOP_BODY` ; Перейти, если `i < size` (`jb` - Jump if Below, для беззнакового сравнения).
        *   **Возврат `sum`:** `mov rax, QWORD PTR [rbp-8]`.
        *   **Эпилог:** `leave`, `ret`.
    *   **Функция `main`:**
        *   Создание стекового кадра, выделение места для `local_var`, массива `numbers`, указателя `my_item`. Массив `numbers` будет инициализирован прямо на стеке последовательными инструкциями `mov`.
        *   **Вызов `malloc`:** `mov edi, 32` (или размер Item с выравниванием), `call malloc@PLT`. Результат (адрес) в RAX, сохраняется в `[rbp - ...]`.
        *   **Проверка `my_item == NULL`:** `cmp QWORD PTR [rbp - ...]`, `jne ...`.
        *   **Доступ к `my_item->id = 101`:** `mov rax, QWORD PTR [rbp - ...]` (адрес item), `mov DWORD PTR [rax], 101` (запись по смещению 0).
        *   **Вызов `snprintf`:** Аргументы (адрес `my_item->name`, размер, форматная строка, "TestItem") загружаются в RDI, RSI, RDX, RCX соответственно. `call snprintf@PLT`.
        *   **Доступ к `my_item->value = 99.5`:** Загрузка константы `99.5` (из `.rodata`) в XMM0, загрузка адреса `my_item` в RAX, `movsd QWORD PTR [rax+24], xmm0`.
        *   **Вызов `process_item`:** Загрузка `my_item` (адрес) в RDI, `local_var` в ESI. `call process_item`.
        *   **Вызов `sum_array`:** Загрузка адреса `numbers` (на стеке) в RDI, размера (5) в ESI. `call sum_array`. Результат в RAX, сохраняется.
        *   **Вызовы `printf`:** Аналогично `snprintf`, аргументы в RDI, RSI, RDX, RCX, ... `call printf@PLT`.
        *   **Вызов `free`:** Загрузка `my_item` (адрес) в RDI. `call free@PLT`.
        *   **Возврат 0:** `mov eax, 0`.
        *   **Эпилог.**
    *   **Ключевые наблюдения (`-O0`):** Очень прямолинейная трансляция. Почти каждая C-переменная имеет свое место на стеке. Много чтений/записей в память (стек), даже если значение уже есть в регистре. Мало используется арифметика адресов (`lea`), чаще загрузка адреса и затем обращение по нему.

3.  **Анализ `analysis_target_O2.s` (Оптимизированный код):**
    *   **Ожидаемые изменения:**
        *   **Агрессивное использование регистров:** Локальные переменные (`sum`, `i`, `local_var`), аргументы (`item_ptr`, `factor`, `array`, `size`), и даже поля структур могут храниться в регистрах дольше, избегая обращений к стеку.
        *   **Упрощение пролога/эпилога:** Может не быть `rbp`-кадра (`-fomit-frame-pointer` часто включен по умолчанию с `-O2`), стек управляется через `rsp`. Пролог/эпилог минимальны или отсутствуют в листовых функциях.
        *   **Инлайнинг (Встраивание):** Если `process_item` покажется компилятору достаточно простой, он может встроить ее код прямо в `main`, убрав `call`. (В нашем случае она не очень простая из-за доступа к глобальной переменной и плавающей точки).
        *   **Развертывание цикла (Loop Unrolling):** Тело `sum_array` может быть развернуто, обрабатывая по 2-4 элемента за итерацию, чтобы уменьшить накладные расходы на проверку условия и инкремент.
        *   **Перестановка инструкций:** Инструкции могут быть переупорядочены для лучшего использования конвейера процессора, скрытия задержек памяти.
        *   **Выбор лучших инструкций:** `lea` для вычисления адресов, `cmov` для условных присваиваний вместо переходов, векторные инструкции (SIMD), если возможно (например, для `sum_array`, хотя в нашем случае условие `if` усложняет векторизацию).
    *   **Пример (Гипотетический фрагмент `sum_array` с -O2):**
        ```assembly
        ; Вместо сохранения array и size на стек, они могут остаться в RDI и RSI
        ; sum и i могут быть в регистрах, например, RBX (sum) и RCX (i)
        xor ebx, ebx   ; sum = 0 (используем xor для обнуления регистра)
        xor ecx, ecx   ; i = 0
        test rsi, rsi  ; Проверка size == 0
        je .L_DONE     ; Если 0, выходим
        .L_LOOP:
            movsxd rax, dword ptr [rdi + rcx*4] ; rax = array[i] (используя RDI и RCX)
            cmp rax, 10                     ; Сравнить с 10
            jle .L_SKIP_ADD                 ; Пропустить сложение, если <= 10
            add rbx, rax                    ; sum += array[i] (используя RBX)
        .L_SKIP_ADD:
            inc rcx                         ; i++ (используя RCX)
            cmp rcx, rsi                    ; Сравнить i с size (в RSI)
            jb .L_LOOP                      ; Повторить, если i < size
        .L_DONE:
            mov rax, rbx                    ; Вернуть sum (из RBX)
            ret
        ```
        *Заметьте:* Меньше обращений к стеку, аргументы и локальные переменные живут в регистрах. `xor reg, reg` - идиома для обнуления регистра.
    *   **Ключевые наблюдения (`-O2`):** Код короче, быстрее, но сложнее сопоставить с исходным C. Требуется понимание того, *что* хотел сделать программист, и как компилятор мог достичь того же результата эффективнее. GDB с `-g` все еще помогает, но поток выполнения может сильно отличаться от C-кода.

4.  **Использование GDB для анализа:**
    *   `gdb ./analysis_target` (скомпилированный с `-g`, можно `-O0` или `-O2`)
    *   `b process_item`: Установить точку останова.
    *   `run`: Запустить.
    *   `layout asm` / `layout regs`: Показать ассемблер и регистры.
    *   `info args`: Показать аргументы функции (работает хорошо с отладочной информацией).
    *   `info locals`: Показать локальные переменные.
    *   `si` / `ni`: Шагать по ассемблерным инструкциям.
    *   `p item_ptr->id`: Показать значение поля (GDB понимает C-синтаксис).
    *   `x/4dw $rbp-32` (пример): Посмотреть 4 dword в памяти, начиная с адреса `rbp-32`.
    *   `disassemble /m process_item`: Показать ассемблерный код функции с соответствующими строками C (если скомпилировано с `-g`).

---

### Глава 7: Устройство исполняемых файлов. ELF и EXE (Углубленно)

**Цель:** Детально изучить структуру и семантику основных форматов исполняемых файлов ELF (Linux) и PE (Windows), понять их роль в процессе загрузки и выполнения программ.

1.  **ELF (Executable and Linkable Format) – Глубокое погружение:**
    *   **Обзор:** Стандарт для исполняемых файлов, объектных кодов (`.o`), разделяемых библиотек (`.so`) и core-дампов в Linux и многих Unix-подобных системах. Гибкий и расширяемый.
    *   **ELF Header (`Elf64_Ehdr` структура):** Находится в самом начале файла.
        *   `e_ident[EI_NIDENT]`: Массив идентификации (16 байт).
            *   `EI_MAG0..3`: `0x7F, 'E', 'L', 'F'` - магическое число.
            *   `EI_CLASS`: `1` (32-bit) или `2` (64-bit).
            *   `EI_DATA`: `1` (Little Endian) или `2` (Big Endian).
            *   `EI_VERSION`: Версия ELF (обычно `1`).
            *   `EI_OSABI`: Целевая ОС ABI (e.g., `0`=System V, `3`=Linux).
            *   `EI_ABIVERSION`: Версия ABI.
            *   `EI_PAD`: Неиспользуемые байты.
        *   `e_type`: Тип файла (`ET_NONE`, `ET_REL`=Объектный, `ET_EXEC`=Исполняемый, `ET_DYN`=Разделяемая библиотека, `ET_CORE`=Core dump).
        *   `e_machine`: Архитектура (`EM_386`, `EM_X86_64`, `EM_ARM`, etc.).
        *   `e_version`: Версия ELF (обычно `1`).
        *   `e_entry`: **Виртуальный адрес точки входа** - адрес первой инструкции программы (для `ET_EXEC`, `ET_DYN`).
        *   `e_phoff`: Смещение (от начала файла) до Program Header Table.
        *   `e_shoff`: Смещение до Section Header Table.
        *   `e_flags`: Флаги, зависящие от процессора.
        *   `e_ehsize`: Размер этого заголовка (ELF Header).
        *   `e_phentsize`: Размер одной записи в Program Header Table.
        *   `e_phnum`: Количество записей в Program Header Table.
        *   `e_shentsize`: Размер одной записи в Section Header Table.
        *   `e_shnum`: Количество записей в Section Header Table.
        *   `e_shstrndx`: Индекс секции имен строк заголовков секций в Section Header Table.
        *   **Команда:** `readelf -h <file>`
    *   **Program Header Table (`Elf64_Phdr` структура):** Описывает *сегменты* файла - как файл должен быть отображен в память загрузчиком ОС. Порядок сегментов важен.
        *   `p_type`: Тип сегмента:
            *   `PT_LOAD`: Загружаемый сегмент. Содержит код, данные и т.д., которые нужно отобразить в память. Ключевой тип для загрузчика.
            *   `PT_DYNAMIC`: Информация для динамической линковки.
            *   `PT_INTERP`: Путь к интерпретатору (динамическому загрузчику, e.g., `/lib64/ld-linux-x86-64.so.2`).
            *   `PT_NOTE`: Вспомогательная информация.
            *   `PT_PHDR`: Указывает на саму Program Header Table в памяти.
            *   `PT_TLS`: Thread-Local Storage.
            *   `PT_GNU_STACK`: Определяет, является ли стек исполняемым (обычно нет).
            *   `PT_GNU_RELRO`: Read-Only Relocations (защита GOT).
        *   `p_flags`: Права доступа к сегменту в памяти (`PF_R`=Read, `PF_W`=Write, `PF_X`=Execute). Обычно один сегмент для кода (R+X) и один для данных (R+W).
        *   `p_offset`: Смещение сегмента от начала файла.
        *   `p_vaddr`: Виртуальный адрес, по которому сегмент должен быть загружен в память.
        *   `p_paddr`: Физический адрес (обычно игнорируется в современных ОС или равен `p_vaddr`).
        *   `p_filesz`: Размер сегмента в файле.
        *   `p_memsz`: Размер сегмента в памяти (`p_memsz >= p_filesz`). Если больше, разница (часто для `.bss`) заполняется нулями.
        *   `p_align`: Требуемое выравнивание сегмента в памяти (обычно размер страницы, 4K).
        *   **Команда:** `readelf -l <file>`
    *   **Section Header Table (`Elf64_Shdr` структура):** Описывает *секции* файла - логические части с кодом, данными, символами и т.д. Важны для линковщика, отладчика, но не обязательны для выполнения (можно удалить `strip`-ом).
        *   `sh_name`: Смещение имени секции в таблице строк имен секций (`.shstrtab`).
        *   `sh_type`: Тип секции:
            *   `SHT_PROGBITS`: Код или данные программы (`.text`, `.data`, `.rodata`).
            *   `SHT_SYMTAB`: Таблица символов (для линковки).
            *   `SHT_STRTAB`: Таблица строк (имена символов, файлов).
            *   `SHT_RELA` / `SHT_REL`: Информация о релокациях (с явным/неявным дополнением).
            *   `SHT_HASH` / `SHT_GNU_HASH`: Хеш-таблица символов для динамического линковщика.
            *   `SHT_DYNAMIC`: Информация для динамической линковки.
            *   `SHT_NOTE`: См. `PT_NOTE`.
            *   `SHT_NOBITS`: Секция не занимает места в файле (`.bss`).
            *   `SHT_DYNSYM`: Минимальная таблица символов для динамической линковки.
        *   `sh_flags`: Атрибуты секции (`SHF_WRITE`, `SHF_ALLOC`=нужно загрузить в память, `SHF_EXECINSTR`=содержит исполняемый код, `SHF_STRINGS`, `SHF_TLS`).
        *   `sh_addr`: Виртуальный адрес секции в памяти (если `SHF_ALLOC`).
        *   `sh_offset`: Смещение секции от начала файла.
        *   `sh_size`: Размер секции в файле.
        *   `sh_link`: Индекс связанной секции (e.g., `SHT_SYMTAB` ссылается на `SHT_STRTAB`).
        *   `sh_info`: Дополнительная информация (зависит от типа секции).
        *   `sh_addralign`: Требуемое выравнивание.
        *   `sh_entsize`: Размер записи (для секций с таблицами, e.g., размер символа в `SHT_SYMTAB`).
        *   **Команда:** `readelf -S <file>` или `readelf -W -S <file>` для широкого вывода.
    *   **Секции (Содержимое):**
        *   `.text`: Исполняемый машинный код.
        *   `.rodata`: Данные только для чтения (строки, константы).
        *   `.data`: Инициализированные глобальные и статические переменные.
        *   `.bss`: Неинициализированные глоб./стат. переменные (только размер).
        *   `.interp`: Путь к `ld-linux.so`.
        *   `.dynsym`: Таблица символов для динамического линкера.
        *   `.dynstr`: Строки для `.dynsym`.
        *   `.rela.dyn` / `.rela.plt`: Релокации для данных и PLT соответственно. `Elf64_Rela` содержит смещение, тип релокации и дополнение. Типы: `R_X86_64_GLOB_DAT` (GOT-запись), `R_X86_64_JUMP_SLOT` (PLT-запись), `R_X86_64_RELATIVE` (относительно базы загрузки), `R_X86_64_64` (абсолютный адрес).
        *   `.plt`: Procedure Linkage Table (см. ниже).
        *   `.got`: Global Offset Table (см. ниже).
        *   `.plt.got`: Иногда используется для ленивой резолюции PLT записей.
        *   `.init` / `.fini`: Код инициализации/финализации (устарело, используется `.init_array` / `.fini_array`).
        *   `.init_array` / `.fini_array`: Массивы указателей на функции конструкторов/деструкторов.
        *   `.symtab` / `.strtab`: Полная таблица символов и строк (для линковки/отладки).
        *   `.shstrtab`: Строки имен секций.
        *   **Команда:** `readelf -x .<section_name> <file>` (dump секции), `objdump -d <file>` (дизассемблировать `.text`), `objdump -tT <file>` (символы).
    *   **Динамическая линковка (ELF):**
        1.  Ядро загружает исполняемый файл и указанный в `PT_INTERP` загрузчик (`ld-linux.so`).
        2.  Управление передается загрузчику.
        3.  Загрузчик читает `PT_DYNAMIC` сегмент исполняемого файла:
            *   Находит необходимые библиотеки (`DT_NEEDED`).
            *   Рекурсивно загружает их (отображает их `PT_LOAD` сегменты в память), выполняя такой же процесс.
            *   Выполняет релокации (`DT_RELA`, `DT_REL`): исправляет адреса в коде и данных, используя таблицы символов (`DT_SYMTAB`, `DT_STRTAB`, `DT_HASH`/`DT_GNU_HASH`). Релокации типа `R_X86_64_RELATIVE` исправляются сразу (адреса внутри самого модуля, зависят от базы загрузки - ASLR).
            *   Инициализирует **GOT** и **PLT**.
                *   **GOT:** Таблица, хранящая *реальные адреса* глобальных переменных и функций (как внутренних, так и внешних). Для внешних данных релокация `R_X86_64_GLOB_DAT` заставляет загрузчик найти символ и записать его адрес в соответствующую GOT-запись.
                *   **PLT:** Таблица "трамплинов" для вызова внешних функций. Вызов `call function@PLT` приводит к:
                    *   `jmp [GOT-entry-for-function]` ; Перейти по адресу из GOT
                    *   При первой загрузке (ленивая привязка) GOT-запись указывает *обратно* на следующую инструкцию в PLT-записи.
                    *   `push index` ; Поместить индекс функции на стек
                    *   `jmp [PLT]` ; Перейти к общему коду разрешения имен в PLT/загрузчике
                    *   Код разрешения находит реальный адрес функции (используя `index` и таблицы символов), **записывает этот адрес в GOT-запись функции** и передает управление на реальную функцию.
                    *   При *последующих* вызовах `jmp [GOT-entry-for-function]` сразу перейдет на реальную функцию, т.к. GOT уже обновлен.
            *   Вызывает функции инициализации (`.init_array`).
        4.  Передает управление на точку входа (`e_entry`) исполняемого файла (которая обычно вызывает `main`).
        *   **Команды:** `ldd <file>` (показать зависимости), `readelf -d <file>` (динамическая секция), `readelf -r <file>` (релокации), `objdump -R <file>` (динамические релокации).

2.  **PE (Portable Executable) – Глубокое погружение:**
    *   **Обзор:** Формат для `.exe`, `.dll`, `.sys`, `.obj` в Windows (32- и 64-bit). Основан на COFF.
    *   **Структура файла (упрощенно):**
        1.  **DOS Header (`IMAGE_DOS_HEADER`):**
            *   `e_magic`: `0x5A4D` ('MZ') - сигнатура MS-DOS.
            *   `e_lfanew`: **Смещение** (от начала файла) до PE Signature. Ключевое поле.
        2.  **DOS Stub:** Небольшая программа (часто выводит "This program cannot be run in DOS mode").
        3.  **PE Signature:** `0x00004550` ('PE\0\0') по смещению `e_lfanew`.
        4.  **COFF File Header (`IMAGE_FILE_HEADER`):** Сразу после PE Signature.
            *   `Machine`: Архитектура (`IMAGE_FILE_MACHINE_AMD64`, `I386`, `ARM`, etc.).
            *   `NumberOfSections`: Количество секций в файле.
            *   `TimeDateStamp`: Время компиляции.
            *   `PointerToSymbolTable`, `NumberOfSymbols`: Для COFF символов (обычно 0 в исполняемых).
            *   `SizeOfOptionalHeader`: Размер следующего заголовка.
            *   `Characteristics`: Флаги (`IMAGE_FILE_EXECUTABLE_IMAGE`, `IMAGE_FILE_DLL`, `IMAGE_FILE_RELOCS_STRIPPED`, `IMAGE_FILE_LARGE_ADDRESS_AWARE`).
        5.  **Optional Header (`IMAGE_OPTIONAL_HEADER32/64`):** Самый большой заголовок. **Не опционален** для исполняемых файлов! Содержит ключевую информацию для загрузчика Windows.
            *   `Magic`: `0x10b` (PE32) или `0x20b` (PE32+ / 64-bit).
            *   `AddressOfEntryPoint`: **RVA** (Relative Virtual Address - смещение от `ImageBase`) точки входа.
            *   `ImageBase`: Предпочтительный виртуальный адрес загрузки модуля в память (e.g., `0x400000` для EXE, `0x10000000` для DLL). Если адрес занят, загрузчик переместит модуль и применит базовые релокации.
            *   `SectionAlignment`: Выравнивание секций в памяти (обычно размер страницы).
            *   `FileAlignment`: Выравнивание секций в файле (обычно 512 байт).
            *   `SizeOfImage`: Общий размер модуля в виртуальной памяти.
            *   `SizeOfHeaders`: Размер всех заголовков + таблицы секций (выровненный по `FileAlignment`).
            *   `Subsystem`: Тип приложения (`IMAGE_SUBSYSTEM_WINDOWS_GUI`, `WINDOWS_CUI`, `NATIVE`).
            *   `DllCharacteristics`: Флаги безопасности (`IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE`=ASLR, `NX_COMPAT`, `HIGH_ENTROPY_VA`).
            *   `SizeOfStackReserve`, `SizeOfStackCommit`: Размеры резервируемого/комитируемого стека.
            *   `SizeOfHeapReserve`, `SizeOfHeapCommit`: Размеры кучи.
            *   `NumberOfRvaAndSizes`: Количество записей в `DataDirectory`.
            *   **`DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]`:** Массив структур `IMAGE_DATA_DIRECTORY`, каждая содержит RVA и размер важной таблицы данных. Ключевые индексы:
                *   `IMAGE_DIRECTORY_ENTRY_EXPORT` (0): Таблица экспорта (для DLL).
                *   `IMAGE_DIRECTORY_ENTRY_IMPORT` (1): Таблица импорта.
                *   `IMAGE_DIRECTORY_ENTRY_RESOURCE` (2): Ресурсы (иконки, диалоги).
                *   `IMAGE_DIRECTORY_ENTRY_BASERELOC` (5): Таблица базовых релокаций.
                *   `IMAGE_DIRECTORY_ENTRY_DEBUG` (6): Отладочная информация.
                *   `IMAGE_DIRECTORY_ENTRY_IAT` (12): Import Address Table (часто совпадает с таблицей импорта, но может быть отдельной).
        6.  **Section Table (`IMAGE_SECTION_HEADER` массив):** Описывает секции. Количество записей = `NumberOfSections`.
            *   `Name`: Имя секции (e.g., `.text`, `.data`, `.rdata`).
            *   `VirtualSize`: Реальный размер секции в памяти.
            *   `VirtualAddress`: RVA секции.
            *   `SizeOfRawData`: Размер секции в файле (выровненный по `FileAlignment`).
            *   `PointerToRawData`: Смещение секции от начала файла.
            *   `Characteristics`: Флаги (`IMAGE_SCN_CNT_CODE`, `CNT_INITIALIZED_DATA`, `CNT_UNINITIALIZED_DATA`, `MEM_EXECUTE`, `MEM_READ`, `MEM_WRITE`).
        7.  **Данные секций:** Содержимое `.text`, `.data`, `.rdata`, etc. по смещениям `PointerToRawData`.
    *   **Динамическая линковка (PE):**
        1.  Загрузчик Windows (в `ntdll.dll`) читает PE заголовки.
        2.  Определяет `ImageBase`. Если он свободен, отображает файл в память по этому адресу. Если занят, выбирает новый базовый адрес (ASLR) и применяет базовые релокации (`IMAGE_DIRECTORY_ENTRY_BASERELOC`) для исправления абсолютных адресов в коде/данных.
        3.  Читает таблицу импорта (`IMAGE_DIRECTORY_ENTRY_IMPORT`). Для каждой записи `IMAGE_IMPORT_DESCRIPTOR` (одна на DLL):
            *   Загружает требуемую DLL (используя `LoadLibrary` или его внутренний эквивалент), если она еще не загружена. Рекурсивно повторяет процесс для зависимостей DLL.
            *   Находит адреса импортируемых функций (по имени или ординалу) в загруженной DLL, используя ее таблицу экспорта.
            *   Записывает найденные адреса функций в **Import Address Table (IAT)** этого модуля. IAT - это массив указателей на функции.
        4.  Код программы вызывает импортируемые функции через косвенный вызов `call [iat_entry_for_function]`. Загрузчик заранее заполнил IAT правильными адресами.
        5.  Передает управление на `AddressOfEntryPoint` (RVA + реальная база загрузки).
    *   **Инструменты Windows:**
        *   `dumpbin` (из Visual Studio): `/headers`, `/sections`, `/imports`, `/exports`, `/disasm`, `/relocations`, `/all`.
        *   Графические: PE-bear, CFF Explorer, PEView.

3.  **Сравнение ELF и PE:**
    *   **Общие цели:** Описать код, данные, зависимости, точку входа для загрузчика ОС.
    *   **Структура:** Оба имеют заголовки, таблицы секций/сегментов. PE имеет наследие DOS.
    *   **Динамическая линковка:** ELF использует GOT/PLT (часто с ленивой привязкой). PE использует IAT (обычно привязка при загрузке).
    *   **Адресация:** ELF часто использует RIP-относительную адресацию (PIE/PIC). PE использует ImageBase + RVA и базовые релокации при перемещении.
    *   **Гибкость:** ELF считается более гибким в плане добавления новых секций/сегментов.

---

### Глава 8: Hex редакторы - все это байты (Углубленно)

**Цель:** Получить практический опыт работы с файлами на уровне байтов, научиться находить структуры данных (заголовки, код, строки) в бинарном представлении и понимать последствия их модификации.

1.  **Представление в Hex-редакторе:**
    *   **Смещение (Offset):** Адрес байта от начала файла, обычно в hex (e.g., `00000000`, `00000010`, ...).
    *   **Hex-панель:** Отображение каждого байта как двух шестнадцатеричных цифр (00-FF). Обычно 8, 16 или 32 байта в строке.
    *   **Текстовая панель:** Отображение тех же байтов, интерпретированных как символы ASCII (или другой выбранной кодировки). Непечатаемые символы заменяются точкой (`.`) или другим символом-заполнителем.
    *   **Редактирование:** Можно изменять байты как в hex-панели, так и (для печатаемых символов) в текстовой. Изменения синхронизируются.

2.  **Практика с `hello_syscall` (ELF):**
    *   Скомпилируйте `hello_syscall.asm` (из Главы 5) и откройте исполняемый файл `hello_syscall` в hex-редакторе (например, `hexedit hello_syscall`).
    *   **ELF Header (Первые 64 байта для elf64):**
        *   **Смещение 0x00:** `7F 45 4C 46` - Магическое число `\x7FELF`.
        *   **Смещение 0x04:** `02` - Класс (2 = 64-bit).
        *   **Смещение 0x05:** `01` - Данные (1 = Little Endian).
        *   **Смещение 0x06:** `01` - Версия ELF.
        *   **Смещение 0x07:** `00` или `03` - OS ABI (System V или Linux).
        *   ... (пропустим паддинг)
        *   **Смещение 0x10:** `02 00` (Little Endian) -> Тип `ET_EXEC` (2 = Исполняемый).
        *   **Смещение 0x12:** `3E 00` (Little Endian) -> Машина `EM_X86_64` (62 или 0x3E).
        *   **Смещение 0x18 (8 байт):** Адрес точки входа `e_entry` (виртуальный адрес метки `_start`). Сравните его с выводом `readelf -h hello_syscall`. Пример: `00 40 00 00 00 00 00 00` -> `0x400000` (или похожий адрес в типичном диапазоне загрузки).
        *   **Смещение 0x20 (8 байт):** Смещение Program Header Table (`e_phoff`). Обычно сразу после ELF header, так что может быть `40 00 00 00 00 00 00 00` (означает смещение 0x40 = 64 байта).
        *   **Смещение 0x28 (8 байт):** Смещение Section Header Table (`e_shoff`). Будет где-то дальше в файле.
        *   ... (Размеры заголовков, количество записей - сравните с `readelf -h`).
    *   **Поиск строки "Hello, NASM Syscall!":** Используйте функцию поиска (часто `/` или Ctrl+F) в hex-редакторе для поиска текстовой строки или последовательности hex-байт (`48 65 6C 6C ...`). Вы найдете ее в файле по смещению, которое соответствует секции `.data` (посмотрите `readelf -S hello_syscall`, найдите смещение `.data`).
    *   **Поиск кода `_start`:** Точка входа (`e_entry`) указывает на виртуальный адрес. Нам нужно найти файловое смещение секции `.text` (из `readelf -S`) и добавить смещение `_start` внутри `.text` (обычно 0). По этому смещению вы увидите байты машинного кода:
        *   `mov rax, 1`: `48 C7 C0 01 00 00 00` (48=REX.W префикс, C7=mov r/m64, imm32, C0=операнд RAX, 01000000=число 1)
        *   `mov rdi, 1`: `48 C7 C7 01 00 00 00` (C7=операнд RDI)
        *   `mov rsi, message`: `48 BE ?? ?? ?? ?? ?? ?? ?? ??` (48=REX.W, BE=mov rsi, imm64, далее 8 байт адреса `message`)
        *   `mov rdx, msglen`: `48 BA ?? ?? ?? ?? 00 00 00 00` (48=REX.W, BA=mov rdx, imm64, далее 8 байт длины - будет 21 или 0x15)
        *   `syscall`: `0F 05`
        *   `mov rax, 60`: `48 C7 C0 3C 00 00 00` (3C = 60)
        *   `mov rdi, 0`: `48 C7 C7 00 00 00 00`
        *   `syscall`: `0F 05`
    *   **Модификация (ОСТОРОЖНО!):**
        *   Найдите байт `0x48` ('H') строки "Hello" в секции данных. Измените его на `0x4A` ('J'). Сохраните файл под новым именем (`hello_syscall_mod`).
        *   Запустите `./hello_syscall_mod`. Он должен вывести "Jello...".
        *   Найдите байт `0x3C` (60 - номер `sys_exit`) в коде. Измените его на `0x01` (номер `sys_write`). Сохраните. Запустите. Программа, скорее всего, упадет с ошибкой сегментации (Segmentation fault), потому что после `syscall(1)` она попытается выполнить `mov rdi, 0` и `syscall`, ожидая, что это `exit`, но ядро будет ждать других аргументов для `write`, что приведет к некорректному поведению и сбою. Это показывает, как изменение даже одного байта в коде может быть фатальным.

3.  **Практика с Программой Windows (e.g., `notepad.exe`):**
    *   Откройте `C:\Windows\notepad.exe` в hex-редакторе.
    *   **Смещение 0x00:** `4D 5A` ('MZ') - DOS Header.
    *   **Найдите смещение PE Signature:** Посмотрите байты по смещению `0x3C` (поле `e_lfanew` в DOS header). Пример: `F8 00 00 00` -> смещение 0xF8.
    *   **Перейдите на это смещение (0xF8):** Вы должны увидеть `50 45 00 00` ('PE\0\0'). Сразу за ним идет COFF Header, затем Optional Header. Попробуйте найти известные поля Optional Header (Machine, NumberOfSections, AddressOfEntryPoint, ImageBase) по их смещениям от начала PE Signature. Сравните с `dumpbin /headers notepad.exe`.

4.  **Выводы:**
    *   Hex-редактор – это "микроскоп" для файлов. Он позволяет увидеть *реальное* содержимое без интерпретации.
    *   Понимание форматов файлов (ELF/PE) позволяет находить и интерпретировать конкретные байты в hex-редакторе.
    *   Любое изменение байтов может повлиять на работу программы, особенно если меняется код или критические структуры данных/заголовки.

---

### Глава 9: Углубляемся в низкоуровневое программирование (Углубленно)

**Цель:** Детально разобрать управление памятью на стеке и в куче, включая механизмы защиты, и изучить продвинутые возможности ассемблера NASM.

1.  **Стек (The Stack) – Очень глубоко:**
    *   **Назначение:** Временное хранилище для вызовов функций, локальных переменных, сохранения регистров. Работает по принципу LIFO. Управляется аппаратно инструкциями `push`, `pop`, `call`, `ret` через регистр `RSP`.
    *   **Стековый кадр (Stack Frame):** Логическая область на стеке, выделяемая для одного вызова функции.
        *   **Стандартный пролог с RBP:**
            ```assembly
            my_function:
                push rbp      ; 1. Сохранить RBP вызывающей функции на стек (RSP уменьшается на 8).
                mov rbp, rsp  ; 2. Установить RBP текущей функции на текущую вершину стека. Теперь RBP - фиксированная база кадра.
                sub rsp, 16   ; 3. Выделить место (16 байт) для локальных переменных, двигая RSP вниз.
                ; ... (сохранение callee-saved регистров, если нужно)
            ```
        *   **Структура стекового кадра (адреса растут вверх):**
            ```
            +-------------------------+ <-- Адрес выше (старые данные стека)
            | ...                     |
            +-------------------------+
            | Аргумент N (если > 6)   | \
            +-------------------------+  |
            | ...                     |  | Передано вызывающей функцией
            +-------------------------+  | ДО инструкции CALL
            | Аргумент 7              | /
            +-------------------------+ <-- RSP перед CALL
            | Адрес возврата          | <-- Помещен CALL, RSP указывает сюда при входе в функцию
            +-------------------------+
            | Сохраненный RBP (старый)| <-- Помещен PUSH RBP (шаг 1), RSP здесь после шага 1
            +-------------------------+ <-- RBP указывает сюда после шага 2. База кадра.
            | Локальная переменная 1  | \
            +-------------------------+  | Место выделено SUB RSP (шаг 3)
            | Локальная переменная 2  |  | Адресация: [rbp - 8], [rbp - 16], ...
            +-------------------------+ /
            | (Padding для выравнивания)|
            +-------------------------+
            | Сохраненный RBX         | \
            +-------------------------+  | Callee-saved регистры, сохраненные
            | Сохраненный R12         | /  функцией (если она их меняет)
            +-------------------------+ <-- RSP здесь после выделения места и сохранения регистров
            ```
        *   **Доступ:**
            *   Аргументы на стеке: `[rbp + 16]`, `[rbp + 24]`, ... (выше сохраненного RBP и адреса возврата).
            *   Локальные переменные: `[rbp - 8]`, `[rbp - 16]`, ... (ниже RBP).
        *   **Стандартный эпилог:**
            ```assembly
                ; ... (восстановление callee-saved регистров)
                leave         ; Эквивалент: mov rsp, rbp; pop rbp. Восстанавливает RSP и старый RBP.
                ret           ; Снимает адрес возврата со стека в RIP.
            ```
        *   **Оптимизация `-fomit-frame-pointer`:** Компилятор может не использовать `RBP` как базу кадра, а обращаться ко всему относительно `RSP`. Это освобождает `RBP` для общего использования. Пролог/эпилог могут исчезнуть или быть проще (`sub rsp, N` / `add rsp, N`). Отладка становится сложнее.
        *   **Выравнивание стека (ABI):** Перед `call` стек должен быть выровнен по 16 байт. `call` помещает 8 байт адреса возврата, нарушая выравнивание. Поэтому внутри функции `RSP` часто сдвигается на величину, которая делает `RSP` перед следующим `call` кратным 16 (учитывая `push rbp`).
        *   **Red Zone (ABI):** 128 байт *ниже* текущего `RSP` считаются "безопасными" для использования *листовыми* функциями (которые не вызывают другие функции) без явного сдвига `RSP`. Компилятор может использовать эту зону для временных данных. Сигналы и прерывания не должны ее портить. Флаг `-mno-red-zone` отключает эту оптимизацию.
    *   **Stack Smashing (Переполнение буфера на стеке):**
        ```c
        // vulnerable.c
        #include <stdio.h>
        #include <string.h>
        void vulnerable_function(char *input) {
            char buffer[64]; // Буфер на стеке
            // Нет проверки длины input!
            strcpy(buffer, input); // Уязвимость!
            printf("Input was: %s\n", buffer);
        }
        int main(int argc, char *argv[]) {
            if (argc != 2) return 1;
            vulnerable_function(argv[1]);
            return 0;
        }
        ```
        *   **Атака:** Если `argv` длиннее ~64 байт, `strcpy` начнет писать за пределы `buffer`. На стеке выше `buffer` лежат сохраненный `RBP` и **адрес возврата** из `vulnerable_function` в `main`. Атакующий может сформировать `argv` так, чтобы перезаписать адрес возврата адресом вредоносного кода (shellcode), который может быть также помещен в `argv` или в переменную окружения.
        *   **Защиты:**
            *   **Stack Canaries (`-fstack-protector*`):** Компилятор вставляет секретное значение (канарейку) на стек между буферами и сохраненными RBP/адресом возврата. Перед `ret` проверяет, не изменилась ли канарейка. Если да - аварийное завершение.
            *   **ASLR (Address Space Layout Randomization):** ОС загружает код, библиотеки, стек, кучу по случайным адресам. Затрудняет атакующему предсказание адреса shellcode или нужных гаджетов ROP.
            *   **NX Bit (No-Execute) / DEP (Data Execution Prevention):** Аппаратная возможность пометить страницы памяти (например, стек, кучу) как неисполняемые. Запрещает выполнение shellcode, помещенного в данные. Приводит к развитию техник ROP/JOP (Return/Jump-Oriented Programming), использующих существующий код программы.

2.  **Куча (The Heap) – Внутренности `malloc`:**
    *   **Назначение:** Динамическое выделение памяти произвольного размера во время выполнения. Управляется библиотечными функциями (`malloc`, `free`, `calloc`, `realloc` из `libc`).
    *   **Системные вызовы:** `malloc` сама получает большие куски памяти от ОС через:
        *   `brk(addr)` / `sbrk(increment)`: Увеличивает/уменьшает границу **сегмента данных** процесса (program break). Просто и быстро для небольших последовательных выделений, но приводит к фрагментации и сложностям с возвратом памяти ОС.
        *   `mmap(addr, len, prot, flags, fd, offset)` / `munmap(addr, len)`: Отображает/убирает страницы памяти (из файла или анонимные) в адресное пространство процесса. Более гибко, позволяет возвращать память ОС, используется для больших (>128KB) выделений в `glibc`.
        *   `strace -e trace=memory ./my_program_using_malloc` покажет вызовы `brk` и `mmap`.
    *   **Управление блоками (Chunks) в `glibc` (ptmalloc2 - упрощенно):**
        *   Память, полученная от ОС, делится на **чанки (chunks)**.
        *   Каждый чанк (как занятый, так и свободный) имеет **заголовок** (header) перед пользовательскими данными. Заголовок хранит:
            *   Размер *предыдущего* чанка (если он свободен).
            *   Размер *текущего* чанка и флаги (A=Arena, M=mmap'ed, P=Previous in use).
        *   **Свободные чанки:** Дополнительно содержат указатели `fd` (forward) и `bk` (backward) для включения в **связные списки свободных блоков (free lists / bins)**.
        *   **Bins (Корзины):** Списки свободных чанков, сгруппированные по размерам для ускорения поиска подходящего блока:
            *   **Fastbins:** Для очень маленьких размеров (до ~80 байт на x64). Односвязные списки (только `fd`). `malloc` сначала смотрит сюда. `free` просто добавляет в начало (LIFO). Нет объединения (coalescing).
            *   **Unsorted Bin:** "Чистилище". Сюда попадают блоки после `free` из small/large bins или остатки после `malloc` из больших блоков. При следующем `malloc` блоки из unsorted bin обрабатываются: маленькие попадают в small bins, большие - в large bins, попутно происходит объединение (coalescing) с соседями.
            *   **Small Bins:** Двусвязные списки ( `fd`, `bk`). Каждый бин для одного фиксированного маленького размера (шаг 8/16 байт). Блоки в бине не отсортированы.
            *   **Large Bins:** Двусвязные списки. Каждый бин для диапазона больших размеров. Блоки внутри бина отсортированы по убыванию размера.
        *   **Процесс `malloc(size)`:**
            1.  Рассчитать нужный размер чанка (включая заголовок, выравнивание).
            2.  Проверить fastbins (если размер подходит). Если есть - вернуть первый.
            3.  Если нет в fastbins -> проверить small bin. Если есть - отцепить и вернуть.
            4.  Если нет -> обработать unsorted bin (переместить блоки в small/large bins, объединить). Снова проверить small/large bins.
            5.  Если нет -> проверить large bin. Найти наименьший подходящий блок. Если он больше нужного, **расщепить** его (остаток поместить в unsorted bin). Вернуть нужную часть.
            6.  Если нет подходящего -> взять блок `top chunk` (остаток памяти арены). Если он подходит - расщепить, вернуть.
            7.  Если `top chunk` мал -> расширить `top chunk` с помощью `sbrk` или запросить новую память через `mmap` (если размер большой или для новой арены). Создать новый чанк, вернуть.
        *   **Процесс `free(ptr)`:**
            1.  Получить адрес заголовка чанка из `ptr`.
            2.  Проверить валидность заголовка.
            3.  Проверить флаг P (Previous in use). Если предыдущий свободен -> **объединить** с предыдущим.
            4.  Проверить следующий чанк. Если он свободен -> **объединить** с ним.
            5.  Поместить итоговый (возможно, объединенный) свободный чанк в соответствующий bin (fastbin или unsorted bin).
    *   **Уязвимости Кучи:** Сложны, но мощны. Цель - получить контроль над метаданными (заголовками, `fd`/`bk` указателями) свободных чанков.
        *   **Heap Overflow:** Переполнение буфера в куче может перезаписать заголовок *следующего* чанка. Если этот следующий чанк потом освобождается (`free`), испорченный заголовок (размер, флаги) может ввести `free` в заблуждение, что приведет к записи "не туда" при объединении или помещении в bin.
        *   **Use-After-Free (UAF):** Программа освобождает (`free`) память, но сохраняет и позже использует указатель на нее (dangling pointer). Если `malloc` перевыделил этот же участок памяти для других данных (возможно, контролируемых атакующим), то использование старого указателя читает/пишет "чужие" данные. Особенно опасно, если там объект с указателями на функции (vtable в C++).
        *   **Double Free:** Повторное `free(ptr)`. Если `ptr` указывает на чанк в fastbin, это может привести к созданию цикла в списке fastbin. Последующие `malloc`-и могут вернуть *один и тот же* адрес дважды, позволяя атакующему контролировать метаданные (например, `fd` указатель). Если чанк не в fastbin, это может повредить списки small/large bins при попытке двойного объединения.
        *   **Атаки на `malloc`/`free`:** Существует множество техник (Unsafe Unlink, House of Force/Spirit/Lore/Mind, Poison Null Byte, tcache poisoning...), использующих особенности реализации `malloc` для получения возможности записи по произвольному адресу (Write-What-Where), что обычно ведет к захвату контроля над выполнением.
        *   **Защиты:** ASLR, NX/DEP, hardening метаданных кучи (проверки консистентности в `malloc`/`free`),隔离 (segregation) метаданных от данных, современные аллокаторы (jemalloc, tcmalloc).

3.  **Продвинутый NASM:**
    *   **Макросы (`%macro`, `%define`, `%assign`, `%if`, `%elif`, `%else`, `%endif`, `%rep`, `%endrep`, `%strlen`, `%substr`, ...):** Мощная система препроцессинга внутри NASM.
        *   **Пример: Макрос для Linux syscall:**
          ```nasm
          %macro LinuxSyscall 1-7 ; Имя макроса и 1-7 аргументов (номер + до 6 параметров)
              mov rax, %1        ; Номер syscall в RAX
              %if %0 >= 2        ; %0 - количество переданных аргументов
                  mov rdi, %2
              %endif
              %if %0 >= 3
                  mov rsi, %3
              %endif
              %if %0 >= 4
                  mov rdx, %4
              %endif
              %if %0 >= 5
                  mov r10, %5
              %endif
              %if %0 >= 6
                  mov r8, %6
              %endif
              %if %0 >= 7
                  mov r9, %7
              %endif
              syscall
          %endmacro

          ; Использование:
          section .data
              message db "Hello Macro!", 0xA
              msglen equ $ - message
          section .text
              global _start
          _start:
              LinuxSyscall 1, 1, message, msglen ; write(1, message, msglen)
              LinuxSyscall 60, 0                 ; exit(0)
          ```
    *   **Структуры (`struc`, `endstruc`, `istruc`, `iend`, `at`):** Позволяют определять смещения полей для удобного доступа к данным в памяти.
        ```nasm
        struc Point ; Определяем структуру Point
            .x: resd 1 ; Поле x, резервируем dword (4 байта)
            .y: resd 1 ; Поле y
            .color: resb 1 ; Поле color, байт
        endstruc

        section .bss
            my_point: resb Point_size ; Резервируем память размером со структуру

        section .text
            ; ...
            mov eax, 10
            mov [my_point + Point.x], eax ; Записать 10 в поле x
            mov ebx, [my_point + Point.y] ; Прочитать поле y в EBX
            mov byte [my_point + Point.color], 0xFF ; Записать цвет
            ; ...
        ```
    *   **Локальные метки (`.`):** Уже упоминались, но важны для структурирования кода внутри функций без засорения глобального пространства имен.
    *   **Вызов NASM из C:**
        *   `nasm_routine.asm`:
          ```nasm
          section .text
          global multiply_by_two ; Экспортируем символ для C
          multiply_by_two:
              ; Аргумент (int) приходит в EDI (согласно ABI)
              ; Результат (int) должен быть в EAX
              mov eax, edi     ; Копируем аргумент в EAX
              sal eax, 1       ; Умножаем на 2 (сдвиг влево)
              ret              ; Возврат (результат в EAX)
          ```
        *   `main.c`:
          ```c
          #include <stdio.h>
          #include <stdint.h>

          // Объявляем внешнюю функцию, реализованную в NASM
          extern int32_t multiply_by_two(int32_t input);

          int main() {
              int32_t num = 15;
              int32_t result = multiply_by_two(num);
              printf("%d * 2 = %d\n", num, result); // Выведет 15 * 2 = 30
              return 0;
          }
          ```
        *   **Сборка:**
            1.  `nasm -f elf64 nasm_routine.asm -o nasm_routine.o`
            2.  `gcc main.c nasm_routine.o -o main_app`
            3.  `./main_app`
    *   **SIMD (SSE/AVX) – Краткое введение:**
        *   **Идея:** Single Instruction, Multiple Data. Одна инструкция обрабатывает несколько элементов данных параллельно.
        *   **Регистры:** `XMM0`-`XMM15` (128 бит), `YMM0`-`YMM15` (256 бит, AVX/AVX2), `ZMM0`-`ZMM31` (512 бит, AVX-512). Могут хранить несколько `float`, `double` или `int` разной битности.
        *   **Пример: Сложение двух массивов float (4 элемента) с SSE:**
          ```nasm
          ; float result[4], a[4], b[4];
          ; result = a + b;
          ; Адрес result в RDI, адрес a в RSI, адрес b в RDX

          movaps xmm0, [rsi]     ; Загрузить 4 float из a в XMM0 (movaps - aligned)
          movaps xmm1, [rdx]     ; Загрузить 4 float из b в XMM1
          addps xmm0, xmm1       ; Сложить 4 пары float параллельно (XMM0 = XMM0 + XMM1)
          movaps [rdi], xmm0     ; Сохранить 4 float результата в result
          ```
          Одна инструкция `addps` делает то же, что 4 сложения в скалярном коде. Требует выравнивания данных по 16 байт (`movaps` vs `movups` для невыровненных).
        *   Использование SIMD может дать значительный прирост производительности в вычислениях, обработке графики, видео.

---

### Глава 10: Продвинутое программирование на C - файлы, потоки, ассемблерные вставки (Углубленно)

**Цель:** Глубоко изучить оба уровня файлового ввода/вывода в C (`stdio` и POSIX syscalls), понять их взаимодействие, буферизацию и научиться безопасно и эффективно использовать inline-ассемблер GCC.

1.  **Стандартный ввод/вывод (`stdio.h`) – Под капотом:**
    *   **`FILE` структура:** Непрозрачная структура, определенная в `libc`. Ее поля управляют буферизацией и состоянием потока. Ключевые (концептуальные) поля:
        *   Файловый дескриптор (`int _fileno`): Низкоуровневый дескриптор, полученный от `open()`.
        *   Указатель на буфер (`char *_IO_buf_base`): Начало выделенной памяти для буфера.
        *   Указатель на конец буфера (`char *_IO_buf_end`): Конец буфера.
        *   Указатель на текущую позицию чтения (`char *_IO_read_ptr`).
        *   Указатель на текущую позицию записи (`char *_IO_write_ptr`).
        *   Флаги состояния (`_flags`): Ошибки (`_IO_ERR_SEEN`), конец файла (`_IO_EOF_SEEN`), режим (read/write), тип буферизации.
    *   **Буферизация – Детали:**
        *   **Полная буферизация (`_IOFBF`):** По умолчанию для файлов. Чтение/запись происходит большими блоками (e.g., 4096 байт). Реальный `read`/`write` syscall вызывается только когда буфер пуст (при чтении) или полон (при записи), или при `fflush`/`fclose`. Самая эффективная для дисковых файлов.
        *   **Линейная буферизация (`_IOLBF`):** По умолчанию для интерактивных терминалов (stdout). Запись происходит при заполнении буфера *или* при встрече символа новой строки (`\n`). Чтение обычно происходит по запросу. Удобно для консольного вывода.
        *   **Без буферизации (`_IONBF`):** Обычно для `stderr`. Каждый вызов `fwrite`/`fprintf` и т.п. приводит к немедленному вызову `write` syscall. Гарантирует немедленный вывод ошибок, но менее эффективно.
        *   **Функция `setvbuf(FILE *stream, char *buf, int mode, size_t size)`:** Позволяет явно установить режим (`_IOFBF`, `_IOLBF`, `_IONBF`) и размер буфера (или предоставить свой `buf`).
    *   **Взаимодействие с дескрипторами:**
        *   `int fileno(FILE *stream)`: Возвращает файловый дескриптор, связанный с потоком `FILE*`. Полезно, если нужно использовать низкоуровневые операции (как `fcntl`) с потоком `stdio`.
        *   `FILE *fdopen(int fd, const char *mode)`: Создает поток `FILE*` поверх существующего файлового дескриптора `fd`. Полезно для работы с дескрипторами, полученными от `pipe()`, `socket()`, `dup()`.
    *   **Пример смешивания (ОПАСНО без `fflush`):**
      ```c
      #include <stdio.h>
      #include <unistd.h> // для write

      int main() {
          printf("Hello via printf... "); // Попадает в буфер stdout
          // fflush(stdout); // <-- Если раскомментировать, вывод будет корректным
          write(STDOUT_FILENO, "Hello via write!\n", 17); // Немедленный вывод через syscall
          // Буфер printf может быть сброшен только при завершении программы
          // Вывод: Hello via write!
          //        Hello via printf...
          return 0;
      }
      ```
    *   **Состояние ошибки и конца файла:**
        *   `feof(stream)`: Возвращает true, если достигнут конец файла *во время предыдущей операции чтения*.
        *   `ferror(stream)`: Возвращает true, если произошла ошибка ввода/вывода *во время предыдущей операции*.
        *   `clearerr(stream)`: Сбрасывает флаги `feof` и `ferror`.
        *   Важно проверять обе после операций чтения/записи, особенно `fread`/`fwrite`, которые возвращают количество обработанных элементов, а не специальное значение для EOF/Error.

2.  **Низкоуровневый ввод/вывод (POSIX, `<unistd.h>`, `<fcntl.h>`) – Детали:**
    *   **Файловые дескрипторы (FD):** Маленькие неотрицательные целые числа (`int`). Индексы в таблице открытых файлов процесса, поддерживаемой ядром. Каждая запись в таблице указывает на глобальную структуру файла в ядре (содержит текущую позицию, права доступа, указатель на inode/объект).
    *   **`open(pathname, flags, mode)`:**
        *   `flags`: Битовая маска. Комбинации:
            *   Доступ: `O_RDONLY` (0), `O_WRONLY` (1), `O_RDWR` (2) - обязательны.
            *   Создание: `O_CREAT` (создать, если нет), `O_EXCL` (с `O_CREAT` - ошибка, если файл существует), `O_TRUNC` (обрезать до нуля, если существует и открыт на запись).
            *   Режимы: `O_APPEND` (писать в конец), `O_NONBLOCK` (не блокироваться при чтении/записи на спец.файлах), `O_SYNC`/`O_DSYNC` (синхронная запись).
        *   `mode` (тип `mode_t`): Права доступа (e.g., `0644`) при создании файла с `O_CREAT`. Игнорируется иначе. Учитывает `umask` процесса.
        *   Возвращает наименьший свободный FD или -1 при ошибке (`errno` устанавливается).
    *   **`read(fd, buf, count)`:**
        *   Пытается прочитать *до* `count` байт.
        *   Возвращает:
            *   Число прочитанных байт (может быть $< count$, если достигнут EOF, прочитано из pipe/socket меньше, чем запрошено, или прервано сигналом).
            *   `0`: Конец файла (EOF).
            *   `-1`: Ошибка (`errno` установлен). Распространенные ошибки: `EBADF` (неверный fd), `EFAULT` (неверный `buf`), `EINTR` (прервано сигналом), `EAGAIN`/`EWOULDBLOCK` (при `O_NONBLOCK`, данных нет).
        *   **Важно:** Всегда проверять возвращаемое значение и обрабатывать случаи `< count`, `0` и `-1` (особенно `EINTR`). Часто нужен цикл для чтения точного количества байт.
    *   **`write(fd, buf, count)`:**
        *   Пытается записать `count` байт.
        *   Возвращает:
            *   Число записанных байт (может быть $< count$, если диск полон, достигнут лимит файла, прервано сигналом, записано в pipe/socket меньше).
            *   `-1`: Ошибка (`errno` установлен). Распространенные: `EBADF`, `EFAULT`, `EINTR`, `EAGAIN`/`EWOULDBLOCK`, `EDQUOT`, `ENOSPC`, `EPIPE`.
        *   **Важно:** Аналогично `read`, часто нужен цикл для записи всех данных.
    *   **`close(fd)`:** Закрывает FD. Освобождает запись в таблице процесса. Если это последняя ссылка на файл в системе, ресурсы файла освобождаются. Игнорирование ошибок `close` - плохая практика (особенно для записи, ошибка может быть отложена).
    *   **`lseek(fd, offset, whence)`:** Устанавливает позицию чтения/записи. Не работает для pipe, socket, terminal.
    *   **`fcntl(fd, cmd, ...)`:** Многоцелевая функция. Примеры `cmd`:
        *   `F_GETFL`: Получить флаги дескриптора (e.g., `O_APPEND`, `O_NONBLOCK`).
        *   `F_SETFL`: Установить флаги.
        *   `F_DUPFD`: Дублировать FD (аналогично `dup`).
    *   **`dup(oldfd)` / `dup2(oldfd, newfd)`:** Создают копию FD. Оба дескриптора указывают на одну и ту же запись в таблице открытых файлов ядра (т.е., разделяют позицию, флаги). `dup2` атомарно закрывает `newfd` (если он был открыт) и делает его копией `oldfd`. Используется для перенаправления `stdin`/`stdout`/`stderr` в дочерних процессах (`fork`/`exec`).

3.  **Inline Assembly (GCC) – Безопасность и Эффективность:**
    *   **Синтаксис (Напоминание):**
      ```c
      asm volatile (
          "Template"
          : OutputOperands /* [constraint](var), ... */
          : InputOperands  /* [constraint](var), ... */
          : Clobbers       /* "reg", "memory", "cc", ... */
      );
      ```
    *   **`volatile`:** Почти всегда нужен, если `asm` имеет побочные эффекты (меняет память, вызывает syscall, зависит от порядка) или если его нельзя оптимизировать (удалить, переместить).
    *   **Ограничения (Constraints) – Подробнее:**
        *   **Простые:** `r`(регистр), `m`(память), `i`(константа), `a`(rax), `b`(rbx), `c`(rcx), `d`(rdx), `S`(rsi), `D`(rdi).
        *   **Память:** `m` - любой адрес, `o` - адрес со смещением (`disp(reg)`), `V` - не смещаемый адрес.
        *   **Регистры:** `q` (любой из a,b,c,d), `Q` (любой 8-битный a,b,c,d), `f` (регистр FPU), `t` (верхний регистр FPU), `x` (регистр XMM/YMM/ZMM).
        *   **Другие:** `g` (любой регистр, память или константа), `X` (любой операнд).
        *   **Модификаторы:** `=` (write), `+` (read/write), `&` (early clobber - выходной операнд, который записывается *до* того, как все входные операнды будут прочитаны; важно, если он использует тот же регистр, что и входной).
        *   **Соответствия:** `0`, `1`, ... Используют тот же регистр/память, что и N-й операнд (начиная с 0). Полезно для инструкций типа `add %0, %1` (где `%0` read/write, а `%1` read).
           ```c
           asm ("addl %1, %0" : "+r"(dest) : "r"(src)); // dest = dest + src
           ```
    *   **Clobbers – Почему важны:** Сообщают компилятору, какие регистры (кроме явно перечисленных в output) или ресурсы (`memory`, `cc` - флаги) изменяются внутри `asm`. GCC не будет использовать "испорченные" регистры для хранения важных данных через `asm` блок и перезагрузит их при необходимости. **Забытый clobber - частая причина трудноуловимых багов.** Если `asm` вызывает внешнюю функцию, нужно перечислить *все* caller-saved регистры в clobbers (или использовать специальный `call`-синтаксис `asm`).
    *   **`memory` Clobber:** Необходим, если `asm` блок читает или пишет в память по адресам, которые *не* указаны явно в операндах `m` или `o`. Это запрещает компилятору переупорядочивать обращения к памяти через `asm` блок и заставляет его сбросить кэшированные в регистрах значения переменных перед `asm`.
    *   **Пример: `memcpy` на inline asm (упрощенно, без оптимизаций):**
      ```c
      #include <stddef.h> // size_t

      void my_memcpy_asm(void *dest, const void *src, size_t n) {
          asm volatile (
              "rep movsb" // Повторить movsb RCX раз
              : "+D"(dest), "+S"(src), "+c"(n) // dest в RDI (read/write), src в RSI (read/write), n в RCX (read/write)
              : // Нет чистых входных операндов
              : "memory" // rep movsb читает/пишет память по RSI/RDI
          );
      }
      ```
      *   Используем `+D`, `+S`, `+c` потому что `rep movsb` модифицирует `RDI`, `RSI`, `RCX`.
      *   `memory` clobber обязателен.
      *   **Примечание:** Настоящий `memcpy` в `glibc` гораздо сложнее и оптимизированнее (использует `movsq`, SIMD, выравнивание).
    *   **Альтернативы Inline Asm:**
        *   **Intrinsics:** Функции C, предоставляемые компилятором, которые транслируются напрямую в специфические инструкции (особенно для SIMD: `<immintrin.h>`, `<xmmintrin.h>`, etc.). Более переносимы и безопасны, чем raw asm. Пример: `_mm_add_ps()` для `addps`.
        *   **Отдельные `.asm` файлы:** Писать функции целиком на NASM и линковать с C (как в Главе 9). Дает полный контроль, но сложнее интегрировать.
    *   **Вывод:** Inline `asm` - мощно, но сложно и опасно. Использовать только при крайней необходимости, тщательно проверять ограничения и clobbers, предпочитать intrinsics или отдельные `.asm` файлы, если возможно.

---

### Глава 11: Понимаем работу ОС. Системные вызовы. Glibc/Winapi (Углубленно)

**Цель:** Синтезировать знания о взаимодействии приложения, стандартной библиотеки и ядра ОС через механизм системных вызовов, понять абстракции и различия в Linux (Glibc) и Windows (WinAPI).

1.  **Ядро ОС – Защитник и Менеджер:**
    *   **Пространство ядра (Kernel Space) vs Пространство пользователя (User Space):** Аппаратное разделение (кольца защиты Ring 0 / Ring 3 в x86). Код ядра выполняется в Ring 0 с полными привилегиями. Код приложений - в Ring 3 с ограничениями.
    *   **Основные задачи ядра:**
        *   **Управление процессами:** Создание (`fork`/`execve` в Linux, `CreateProcess` в Windows), планирование (выделение времени ЦП), синхронизация (мьютексы, семафоры в ядре), завершение, управление ресурсами процесса.
        *   **Управление памятью:** Отображение виртуальных адресов на физические (таблицы страниц), выделение/освобождение страниц, свопинг, управление общей памятью, защита памяти (права R/W/X).
        *   **Управление вводом/выводом:** Драйверы устройств (абстрагируют оборудование), файловые системы (VFS в Linux, I/O Manager в Windows), сетевой стек, взаимодействие с контроллерами DMA.
        *   **Интерфейс системных вызовов:** Контролируемая точка входа из User Space в Kernel Space.
    *   **Контекст процесса:** Вся информация, необходимая для выполнения процесса (состояние регистров ЦП, включая `RIP`, `RSP`, `RFLAGS`; таблицы страниц; таблица открытых файлов; состояние сигналов/сообщений; и т.д.). При переключении контекста ядро сохраняет контекст старого процесса и загружает контекст нового.

2.  **Системный вызов – Мост между мирами:**
    *   **Механизм `syscall` (x86-64 Linux):**
        1.  **User Space:** `libc` wrapper (или прямой `asm`) помещает номер syscall в `RAX`, аргументы в `RDI, RSI, RDX, R10, R8, R9`.
        2.  **User Space:** Выполняется инструкция `syscall`.
        3.  **Hardware:** Процессор сохраняет `RIP` (адрес следующей инструкции) в `RCX`, `RFLAGS` в `R11`, переключается на стек ядра, загружает селекторы сегментов ядра (CS/SS) из MSR, загружает адрес обработчика syscall (из `LSTAR` MSR) в `RIP`. Переход в Ring 0.
        4.  **Kernel Space (Entry Point):** Обработчик сохраняет пользовательские регистры (кроме RCX, R11, RAX, и аргументов RDI-R9, которые уже используются), проверяет номер syscall в `RAX`, находит нужную функцию ядра (`sys_read`, `sys_open`, ...) в таблице системных вызовов (`sys_call_table`).
        5.  **Kernel Space:** Выполняется функция ядра (`sys_*`). Она имеет доступ ко всем ресурсам, может блокировать процесс (e.g., ожидание I/O), взаимодействовать с драйверами.
        6.  **Kernel Space:** Результат помещается в `RAX`. Обработчик восстанавливает пользовательские регистры.
        7.  **Kernel Space:** Выполняется инструкция `sysret`.
        8.  **Hardware:** Процессор восстанавливает `RIP` из `RCX`, `RFLAGS` из `R11`, переключается на пользовательский стек, загружает пользовательские CS/SS. Возврат в Ring 3, на инструкцию после `syscall`.
        9.  **User Space:** `libc` wrapper проверяет `RAX`. Если значение отрицательное (в диапазоне -4095..-1), это код ошибки (`-errno`). Wrapper сохраняет `errno` и возвращает -1 приложению. Иначе возвращает значение из `RAX`.
    *   **`int 0x80` (Старый механизм Linux 32-bit):** Медленнее. Номер syscall в `EAX`, аргументы в `EBX, ECX, EDX, ESI, EDI, EBP`. Использует программное прерывание.
    *   **`sysenter`/`sysexit` (Старый механизм Intel 32-bit):** Быстрее `int 0x80`, но сложнее в использовании.
    *   **Windows Syscall:** Использует `syscall` (x64) или `sysenter` (x86). Механизм похож, но номера syscall и ABI отличаются. Интерфейс `ntdll.dll` является шлюзом. Номера могут меняться между версиями Windows (в отличие от Linux, где их стараются стабилизировать). Прямой вызов syscall в Windows крайне не рекомендуется и ненадежен.
    *   **`vDSO` (Virtual Dynamic Shared Object) / SharedUserData (Windows):** Маленькая область памяти, отображаемая ядром в пространство каждого процесса. Содержит данные (e.g., текущее время) и код для очень частых и простых syscalls (e.g., `gettimeofday`, `time`, `getcpu` в Linux; `GetTickCount`, `QueryPerformanceCounter` в Windows). Вызов этих функций из `libc`/`kernel32` может просто перейти к коду в vDSO/SharedUserData, который выполняется в User Mode, избегая дорогостоящего переключения контекста.

3.  **Слой Абстракции – `libc` и `WinAPI`:**
    *   **Зачем?**
        *   **Переносимость:** Код, использующий `printf` или `fopen`, будет работать (с перекомпиляцией) на разных Unix-like системах с разными ядрами, т.к. `libc` предоставляет стандартный интерфейс. Аналогично WinAPI для разных версий Windows.
        *   **Стабильность:** Интерфейс `libc`/WinAPI меняется реже, чем прямые номера/ABI системных вызовов ядра.
        *   **Удобство:** Функции `libc`/WinAPI часто делают больше, чем один syscall (e.g., `printf` форматирует и буферизует вывод, `malloc` управляет кучей).
        *   **Безопасность:** Библиотеки могут выполнять проверки аргументов.
    *   **Glibc (Linux):**
        *   Реализация стандарта C (`stdio`, `stdlib`, `string`, `math`, ...).
        *   Реализация стандарта POSIX (`unistd`, `fcntl`, `sys/types`, `sys/stat`, `pthread`, ...).
        *   Syscall wrappers: Функции с теми же именами, что и syscalls (`read`, `write`, `open`, ...), которые содержат `asm("syscall")` и обработку `errno`.
        *   Динамический загрузчик (`ld-linux.so`).
        *   Интернационализация, Name Service Switch (NSS), и многое другое.
    *   **WinAPI (Windows):**
        *   Не просто C библиотека, а **основной API операционной системы**.
        *   Огромный набор функций, сгруппированных по DLL:
            *   `kernel32.dll`: Базовые функции ОС (процессы, потоки, память, файлы, синхронизация). Пример: `CreateFileW`, `ReadFile`, `WriteFile`, `CreateProcessW`, `CreateThread`, `VirtualAlloc`, `HeapAlloc`, `Sleep`.
            *   `user32.dll`: Пользовательский интерфейс (окна, сообщения, меню, элементы управления). Пример: `CreateWindowExW`, `GetMessageW`, `DispatchMessageW`, `MessageBoxW`.
            *   `gdi32.dll`: Графика (рисование, шрифты, битмапы). Пример: `CreateCompatibleDC`, `SelectObject`, `BitBlt`, `TextOutW`.
            *   `advapi32.dll`: Безопасность, реестр, службы. Пример: `RegOpenKeyExW`, `RegQueryValueExW`, `OpenProcessToken`, `StartServiceW`.
            *   `ntdll.dll`: Недокументированный (в основном) слой Native API. Функции WinAPI часто вызывают функции `Nt*`/`Zw*` из `ntdll`, которые уже делают syscall. Прямое использование `ntdll` может нарушить совместимость.
        *   Использует **Handles** (непрозрачные указатели/идентификаторы) для объектов ядра (файлы, процессы, потоки, мьютексы и т.д.) вместо файловых дескрипторов.
        *   Широко использует кодировку **UTF-16** (Wide Char, `wchar_t`) для строк (функции с суффиксом `W`, e.g., `CreateFileW`). Старые ANSI-версии (суффикс `A`) существуют для совместимости, но преобразуют строки, что менее эффективно.
    *   **Линковка с библиотеками:**
        *   **Linux (динамическая):** `gcc my_code.c -o my_app` автоматически линкует с `libc.so` (и другими по умолчанию, как `libm.so`, если нужны). `ldd ./my_app` показывает зависимости.
        *   **Windows (динамическая):** Компилятор (`cl.exe` или `gcc` из MinGW) использует **библиотеки импорта (`.lib`)**, которые содержат не код, а информацию для линковщика о том, в какой DLL искать нужные функции. Например, при вызове `CreateFileW`, линковщик использует `kernel32.lib`, чтобы узнать, что эта функция находится в `kernel32.dll`. При запуске `.exe` загрузчик Windows найдет и загрузит `kernel32.dll`.

---

### Глава 12: Проект (Углубленные Идеи)

**Цель:** Применить все полученные знания для создания осмысленного низкоуровневого проекта, глубоко проработав выбранную тему.

1.  **Мини-`malloc`/`free` (Углубленно):**
    *   **Задача:** Реализовать свой аллокатор кучи на C, используя `mmap` для получения памяти от ОС.
    *   **Детали:**
        *   Определить структуру заголовка чанка (`chunk_header`), хранящую размер и флаг "занят/свободен". Возможно, указатель на предыдущий чанк для объединения.
        *   Реализовать явный двусвязный список свободных блоков (free list). Указатели `fd`/`bk` хранить прямо в области данных свободных чанков.
        *   Использовать стратегию поиска блока (First Fit, Best Fit?).
        *   Реализовать объединение (coalescing) свободных блоков при `free`.
        *   Реализовать расщепление (splitting) больших блоков при `malloc`, если найденный блок больше запрошенного.
        *   Обработать выравнивание (возвращаемый указатель должен быть выровнен, например, по 16 байт).
        *   Запросить начальный пул памяти у ОС через `mmap(NULL, POOL_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)`. При необходимости запрашивать еще.
        *   Предоставить интерфейс `void *my_malloc(size_t size)` и `void my_free(void *ptr)`.
        *   Написать тесты, проверяющие выделение разных размеров, `free`, повторное использование, объединение, обработку ошибок (запрос слишком большого блока). Использовать `valgrind` для проверки на утечки и ошибки доступа.
    *   **Усложнения:** Добавить поддержку "bins" для ускорения поиска, реализовать `my_realloc`, добавить базовые проверки безопасности (magic numbers в заголовках).

2.  **Простой Дизассемблер x86-64 (Углубленно):**
    *   **Задача:** Написать программу на C или NASM, которая читает `.text` секцию из ELF-файла и дизассемблирует базовые инструкции x86-64.
    *   **Детали:**
        *   Использовать библиотеку для парсинга ELF (как `libelf`) или реализовать ручной парсинг ELF Header и Section Header Table для нахождения смещения и размера секции `.text`.
        *   Читать байты из секции `.text`.
        *   Создать таблицу опкодов для целевых инструкций (e.g., `0x90`=NOP, `0xC3`=RET, `0x50`-`0x57`=PUSH reg, `0x58`-`0x5F`=POP reg, `0x89`=MOV r/m,r, `0x8B`=MOV r,r/m, `0xB8`-`0xBF`=MOV r64,imm64, `0xFF /4`=JMP r/m64, `0xE8`=CALL rel32, `0xEB`=JMP rel8, `0x70`-`0x7F`=Условные JMP rel8).
        *   Для инструкций с операндами (как `MOV`, `ADD`):
            *   Разобрать префиксы (REX `0x4?`, размер операнда `0x66`, размер адреса `0x67`).
            *   Разобрать **байт ModR/M:** определяет режим адресации (регистр/память), номера регистров.
            *   Разобрать **байт SIB (Scale-Index-Base):** если ModR/M указывает на режим с SIB (масштаб, индекс, база).
            *   Разобрать смещение (Displacement) и непосредственное значение (Immediate), если они присутствуют согласно ModR/M и опкоду.
        *   Форматировать вывод в виде `адрес: байты_инструкции мнемоника операнды`.
        *   Обработать хотя бы 20-30 распространенных инструкций и их основные режимы адресации.
    *   **Усложнения:** Поддержка большего числа инструкций, FPU/SSE/AVX инструкций, более сложных режимов адресации, символьное разрешение адресов (используя таблицу символов ELF).

3.  **ELF/PE Инспектор (Углубленно):**
    *   **Задача:** Написать на C инструмент командной строки, детально разбирающий и отображающий структуру ELF или PE файлов.
    *   **Детали:**
        *   Определить структуры C, соответствующие заголовкам ELF (`Elf64_Ehdr`, `Elf64_Phdr`, `Elf64_Shdr`, `Elf64_Sym`, `Elf64_Rela`, `Elf64_Dyn`) или PE (`IMAGE_DOS_HEADER`, `IMAGE_NT_HEADERS64`, `IMAGE_FILE_HEADER`, `IMAGE_OPTIONAL_HEADER64`, `IMAGE_SECTION_HEADER`, `IMAGE_IMPORT_DESCRIPTOR`, etc.).
        *   Открыть файл в бинарном режиме (`fopen(..., "rb")`).
        *   Прочитать заголовок (DOS/ELF), проверить магические числа.
        *   Найти и прочитать основной заголовок (PE/ELF). Распарсить и вывести все поля с понятными именами и интерпретацией флагов/типов.
        *   Найти, прочитать и вывести содержимое Program Headers (ELF) / Section Table (PE).
        *   Найти, прочитать и вывести Section Headers (ELF).
        *   (Опционально, но очень полезно) Реализовать парсинг и вывод:
            *   Таблицы символов (`.symtab`, `.dynsym` в ELF).
            *   Таблицы строк (`.strtab`, `.dynstr`, `.shstrtab` в ELF).
            *   Таблицы релокаций (`.rela.dyn`, `.rela.plt` в ELF; `.reloc` в PE). Интерпретировать типы релокаций.
            *   Динамической секции (`.dynamic` в ELF) / Таблиц импорта/экспорта (PE).
        *   Сделать вывод похожим на `readelf -a` или `dumpbin /all`. Добавить опции командной строки для выбора выводимой информации (`-h` для заголовка, `-S` для секций, etc.).
    *   **Усложнения:** Добавить поддержку обоих форматов (ELF и PE), поддержку 32-битных версий, дизассемблирование `.text` секции, вывод hex-дампов секций.

4.  **Системный Трейсер (а-ля `strace`) (Углубленно):**
    *   **Задача:** Использовать системный вызов `ptrace` в Linux для отслеживания системных вызовов дочернего процесса.
    *   **Детали:**
        *   Родительский процесс использует `fork()` для создания дочернего.
        *   **Дочерний процесс:** Вызывает `ptrace(PTRACE_TRACEME, 0, NULL, NULL)` (разрешает родителю себя трассировать) и затем `execve()` для запуска целевой программы.
        *   **Родительский процесс:** Использует `waitpid()` для ожидания событий от дочернего.
        *   Основной цикл родителя:
            1.  Вызвать `ptrace(PTRACE_SYSCALL, pid, NULL, NULL)`: Продолжить выполнение дочернего процесса до *входа* в следующий системный вызов или *выхода* из него.
            2.  `waitpid()`: Ждать сигнала `SIGTRAP` от дочернего процесса.
            3.  `ptrace(PTRACE_GETREGS, pid, NULL, &regs)`: Получить регистры дочернего процесса (структура `user_regs_struct`).
            4.  **При входе в syscall:** Регистр `orig_rax` (в `regs`) содержит номер системного вызова. Регистры `rdi, rsi, rdx, r10, r8, r9` содержат аргументы. Вывести номер и аргументы (можно декодировать некоторые: числа, простые строки - читать память дочернего процесса через `process_vm_readv` или `ptrace(PTRACE_PEEKDATA, ...)`).
            5.  Снова вызвать `ptrace(PTRACE_SYSCALL, ...)` и `waitpid()` для достижения *выхода* из syscall.
            6.  Снова `ptrace(PTRACE_GETREGS, ...)`
            7.  **При выходе из syscall:** Регистр `rax` содержит возвращаемое значение. Вывести его.
            8.  Повторять цикл, пока дочерний процесс не завершится (`waitpid` вернет ошибку или статус завершения).
        *   Реализовать обработку сигналов, корректное отсоединение (`PTRACE_DETACH`), декодирование хотя бы 10-15 популярных системных вызовов ( `read`, `write`, `openat`, `close`, `mmap`, `brk`, `exit_group`, `stat`, `getuid`, `clone`, `fork`).
    *   **Усложнения:** Декодирование структур, передаваемых по указателю, обработка 32-битных syscalls (через `orig_eax`), опции фильтрации вызовов, форматирование вывода как у `strace`.

5.  **Оптимизированная Подпрограмма (NASM + C) (Углубленно):**
    *   **Задача:** Выбрать вычислительно интенсивную задачу, реализовать на C, профилировать, переписать критическую часть на NASM с использованием SIMD (SSE/AVX), сравнить производительность.
    *   **Примеры задач:**
        *   Умножение матриц (float или double).
        *   Применение фильтра (свертка) к изображению (представленному как массив байт/float).
        *   Быстрый поиск подстроки (алгоритм Бойера-Мура или похожий с SIMD-оптимизациями).
        *   Вычисление контрольной суммы (CRC32 с использованием `crc32` инструкции) или хеша (SHA).
    *   **Детали:**
        *   Написать чистую C-версию.
        *   Тщательно профилировать C-версию (скомпилированную с `-O3`) с помощью `perf record / perf report` или аналогичных инструментов, чтобы найти "горячие точки".
        *   Изучить соответствующие SIMD инструкции (SSE2, AVX, AVX2 - в зависимости от ЦП) для выбранной задачи. Понять требования к выравниванию данных.
        *   Реализовать ядро алгоритма на NASM в отдельном файле `.asm`, экспортируя функцию (`global`). Функция должна следовать System V ABI.
        *   В C-коде объявить `extern` функцию и вызвать ее, передав данные (указатели на массивы/матрицы, размеры). Возможно, потребуется выровненное выделение памяти (`aligned_alloc` или `posix_memalign`).
        *   Слинковать C-код и NASM `.o` файл.
        *   Написать бенчмарк, который многократно запускает обе версии (C и C+NASM) на больших данных и измеряет время выполнения (используя `clock_gettime` или аналоги). Сравнить результаты.
        *   (Бонус) Сравнить вашу NASM-реализацию с ассемблерным кодом, который генерирует GCC/Clang для C-версии с `-O3 -march=native`. Иногда компилятор сам неплохо векторизует код.
    *   **Усложнения:** Использование AVX2 (256-bit регистры) или AVX-512, обработка невыровненных данных или "хвостов" массивов, не кратных размеру вектора SIMD.


### Глава 13: Автоматизация Сборки с `make` и `Makefile`

**Цель:** Научиться использовать утилиту `make` и создавать файлы `Makefile` для автоматизации процесса компиляции, ассемблирования и линковки проектов на C и NASM, управления зависимостями и упрощения повторяющихся задач сборки.

1.  **Зачем нужен `make`? Проблемы ручной сборки:**
    *   **Ручная сборка:** Для простых проектов (1-2 файла) команды типа `nasm -f elf64 file.asm -o file.o` и `gcc main.c file.o -o app` работают.
    *   **Сложности с ростом проекта:**
        *   **Множество файлов:** Ввод длинных команд компиляции/линковки для каждого изменения становится утомительным и подверженным ошибкам.
        *   **Зависимости:** Если изменяется заголовочный файл `header.h`, включенный в несколько `.c` файлов, нужно вручную перекомпилировать *все* эти `.c` файлы, а не только один. Отслеживать это вручную сложно.
        *   **Лишняя работа:** Зачем перекомпилировать `module1.c`, если изменился только `module2.c`? Ручной запуск компиляции для всех файлов неэффективен.
        *   **Повторяемость:** Команды для сборки, очистки проекта, запуска тестов часто одинаковы.
    *   **Решение – `make`:**
        *   Это утилита, которая автоматически определяет, какие части проекта нуждаются в пересборке, и выполняет необходимые команды для их обновления.
        *   Работает на основе файла `Makefile` (или `makefile`), который описывает зависимости между файлами и команды для их создания/обновления.
        *   **Ключевой принцип:** `make` сравнивает время последней модификации файлов. Если файл-зависимость (например, `module.c` или `header.h`) новее, чем файл-цель (например, `module.o`), то `make` выполняет команду для обновления цели.

2.  **Базовая структура `Makefile`:**
    *   `Makefile` состоит из **правил (rules)**.
    *   **Структура правила:**
        ```makefile
        цель: зависимости ...
        <ТАБ> команда1
        <ТАБ> команда2
        <ТАБ> ...
        ```
        *   **`цель` (target):** Имя файла, который нужно создать или обновить (e.g., `my_program`, `module.o`), или имя действия (`all`, `clean`).
        *   **`зависимости` (dependencies/prerequisites):** Файлы или другие цели, от которых зависит `цель`. Если любая из зависимостей новее `цели`, команды будут выполнены.
        *   **`<ТАБ>`:** **Обязательно символ табуляции (Tab)**, не пробелы! Он указывает `make`, что это строка команды.
        *   **`команда` (command/recipe):** Команда оболочки (shell command), которая будет выполнена для создания/обновления `цели`.
    *   **Пример 1: Сборка `hello_syscall` (из Главы 5):**
        ```makefile
        # Makefile for hello_syscall

        # Цель: исполняемый файл hello_syscall
        # Зависимости: объектный файл hello_syscall.o
        hello_syscall: hello_syscall.o
        	ld hello_syscall.o -o hello_syscall # Команда линковки

        # Цель: объектный файл hello_syscall.o
        # Зависимости: ассемблерный файл hello_syscall.asm
        hello_syscall.o: hello_syscall.asm
        	nasm -f elf64 hello_syscall.asm -o hello_syscall.o # Команда ассемблирования
        ```
    *   **Как использовать:**
        1.  Сохраните код выше в файл с именем `Makefile` (или `makefile`) в том же каталоге, что и `hello_syscall.asm`.
        2.  Откройте терминал в этом каталоге.
        3.  Выполните команду `make`.
            *   `make` прочитает `Makefile`.
            *   Он увидит, что цель по умолчанию (первая в файле) – `hello_syscall`.
            *   Он проверит зависимости `hello_syscall` -> `hello_syscall.o`.
            *   Он найдет правило для `hello_syscall.o`. Проверит его зависимости -> `hello_syscall.asm`.
            *   Если `hello_syscall.o` не существует или `hello_syscall.asm` новее `hello_syscall.o`, `make` выполнит команду `nasm ...`.
            *   Затем `make` вернется к цели `hello_syscall`. Теперь `hello_syscall.o` существует (или только что создан).
            *   Если `hello_syscall` не существует или `hello_syscall.o` новее `hello_syscall`, `make` выполнит команду `ld ...`.
        4.  Запустите `make` еще раз. `make` увидит, что `hello_syscall` новее `hello_syscall.o`, а `hello_syscall.o` новее `hello_syscall.asm`. Ничего делать не нужно. Вывод: `make: 'hello_syscall' is up to date.`.
        5.  Измените `hello_syscall.asm` (например, добавьте комментарий) и снова запустите `make`. `make` увидит, что `hello_syscall.asm` новее `hello_syscall.o`, пересоздаст `hello_syscall.o` и затем перелинкует `hello_syscall`.

3.  **Переменные в `Makefile`:**
    *   Позволяют избежать повторений и упростить изменение параметров сборки.
    *   **Определение:**
        *   **Рекурсивные (`=`):** Значение вычисляется при каждом использовании переменной. Позволяет использовать переменные, определенные позже.
          ```makefile
          GREETING = Hello
          MESSAGE = $(GREETING) World
          GREETING = Bye # Теперь MESSAGE будет "Bye World"
          ```
        *   **Простые (`:=`):** Значение вычисляется один раз при определении. Более предсказуемо и часто предпочтительнее.
          ```makefile
          GREETING := Hello
          MESSAGE := $(GREETING) World # MESSAGE будет "Hello World"
          GREETING := Bye # MESSAGE останется "Hello World"
          ```
        *   **Условное присваивание (`?=`):** Присваивает значение, только если переменная еще не определена. Полезно для задания значений по умолчанию, которые можно переопределить из командной строки.
          ```makefile
          CFLAGS ?= -g -O0
          ```
          Можно запустить `make CFLAGS="-g -O2"` чтобы переопределить.
    *   **Использование:** `$(ИМЯ_ПЕРЕМЕННОЙ)` или `${ИМЯ_ПЕРЕМЕННОЙ}`.
    *   **Встроенные переменные:** `make` имеет множество предопределенных переменных:
        *   `CC`: Имя C компилятора (по умолчанию `cc`, обычно ссылка на `gcc`).
        *   `CXX`: Имя C++ компилятора (`g++`).
        *   `AS`: Имя ассемблера (`as`).
        *   `LD`: Имя линковщика (`ld`).
        *   `CFLAGS`: Флаги для C компилятора.
        *   `CXXFLAGS`: Флаги для C++ компилятора.
        *   `ASFLAGS`: Флаги для ассемблера.
        *   `LDFLAGS`: Флаги для линковщика (передаются при линковке через компилятор, e.g., `-L/path/to/lib`).
        *   `LDLIBS`: Библиотеки для линковки (e.g., `-lm`, `-lpthread`).
    *   **Автоматические переменные:** Специальные переменные, доступные внутри команд правила:
        *   `$@`: Имя цели текущего правила.
        *   `$<`: Имя *первой* зависимости.
        *   `$^`: Имена *всех* зависимостей (через пробел, без дубликатов).
        *   `$?`: Имена всех зависимостей, которые *новее* цели.
        *   `$*`: "Основа" имени цели при использовании правил по суффиксам (устарело) или шаблонных правил.
    *   **Пример 1 с переменными:**
        ```makefile
        # Makefile for hello_syscall with variables

        AS = nasm
        ASFLAGS = -f elf64
        LD = ld
        TARGET = hello_syscall

        # Цель по умолчанию
        all: $(TARGET)

        $(TARGET): $(TARGET).o
        	$(LD) $\$$< -o $\$$@ # Используем $< (первая зависимость), $\$$@ (цель)

        $(TARGET).o: $(TARGET).asm
        	$\$$(AS) $\$$(ASFLAGS) $\$$< -o $\$$@ # Используем $\$$<, $@
        ```
        Этот Makefile делает то же самое, но его легче адаптировать (например, изменить ассемблер или флаги). Цель `all` добавлена как "хорошая практика" для явного указания основной цели сборки.

4.  **Шаблонные Правила (Pattern Rules):**
    *   Позволяют определять общие правила для создания файлов одного типа из файлов другого типа на основе их расширений. Используют символ `%` как шаблон.
    *   **Синтаксис:**
        ```makefile
        %.целевое_расширение: %.исходное_расширение
        	команда_используя_автоматические_переменные
        ```
    *   **Пример: Правило для компиляции `.c` в `.o`:**
        ```makefile
        # Шаблонное правило: как создать .o из .c
        %.o: %.c
        	$(CC) $(CFLAGS) -c $< -o $@
        # $(CC) - компилятор C (gcc)
        # $(CFLAGS) - флаги компилятора
        # -c - только компилировать (создать .o)
        # $< - имя исходного .c файла (первая зависимость)
        # $@ - имя целевого .o файла
        ```
    *   **Пример: Правило для ассемблирования `.asm` (NASM) в `.o`:**
        ```makefile
        # Шаблонное правило: как создать .o из .asm (NASM)
        %.o: %.asm
        	nasm -f elf64 $(ASFLAGS) $< -o $@
        ```
    *   **Как `make` использует шаблонные правила:** Если `make` нужна цель (e.g., `main.o`) и для нее нет явного правила, он ищет шаблонное правило, которое может ее создать. Он находит `%.o: %.c`, подставляет `main` вместо `%` и проверяет, существует ли зависимость `main.c`. Если да, он использует это правило.

5.  **Фальшивые Цели (`.PHONY`):**
    *   Цели, которые не представляют реальные файлы, а являются просто именами для набора команд.
    *   Примеры: `all` (собрать все), `clean` (удалить сгенерированные файлы), `install` (установить программу).
    *   **Проблема:** Если в каталоге случайно появится файл с именем `clean`, то команда `make clean` перестанет работать (т.к. `make` посчитает цель `clean` обновленной, ведь файла-зависимостей у нее нет).
    *   **Решение:** Объявить такие цели "фальшивыми" с помощью специальной цели `.PHONY`.
        ```makefile
        .PHONY: all clean

        all: my_program # Зависит от финальной программы

        my_program: main.o module1.o module2.o
        	$(CC) $(LDFLAGS) $^ -o $@ $(LDLIBS) # $^ - все зависимости (.o файлы)

        # Здесь могут быть правила для .o файлов (явные или шаблонные)

        clean:
        	rm -f my_program *.o # Команда для очистки
        # Зависимостей нет, команды выполняются всегда при вызове 'make clean'
        ```
        Теперь `make` будет выполнять команды для `clean` всегда, независимо от существования файла `clean`.

6.  **Пример `Makefile` для проекта C + NASM:**
    *   Допустим, у нас есть:
        *   `main.c` (использует функции из `nasm_module.asm` и `c_module.c`)
        *   `c_module.c` (реализация на C)
        *   `c_module.h` (заголовок для `c_module.c`, включается в `main.c`)
        *   `nasm_module.asm` (реализация на NASM)
    *   `Makefile`:
        ```makefile
        # Имя исполняемого файла
        TARGET = my_combined_app

        # Компиляторы и флаги
        CC = gcc
        AS = nasm
        CFLAGS = -g -Wall -Wextra -I. # -g отладка, -Wall/-Wextra предупреждения, -I. искать .h в текущем каталоге
        ASFLAGS = -f elf64 -g -F dwarf # -g/-F dwarf для отладки NASM кода
        LDFLAGS =
        LDLIBS = # Если нужны внешние библиотеки, например -lm

        # Исходные файлы
        C_SOURCES = main.c c_module.c
        ASM_SOURCES = nasm_module.asm

        # Объектные файлы (автоматически получаем из .c и .asm)
        # Функция $(patsubst шаблон, замена, текст)
        C_OBJECTS = $(patsubst %.c, %.o, $(C_SOURCES))
        ASM_OBJECTS = $(patsubst %.asm, %.o, $(ASM_SOURCES))
        OBJECTS = $(C_OBJECTS) $(ASM_OBJECTS)

        # Цель по умолчанию (первая цель)
        all: $(TARGET)

        # Правило линковки
        $(TARGET): $(OBJECTS)
        	$(CC) $(LDFLAGS) $^ -o $@ $(LDLIBS)
        	@echo "Build finished: $@" # @ перед командой подавляет ее вывод

        # Шаблонное правило для компиляции C -> .o
        %.o: %.c c_module.h # Добавляем .h в зависимости!
        	$(CC) $(CFLAGS) -c $< -o $@

        # Шаблонное правило для ассемблирования NASM -> .o
        %.o: %.asm
        	$(AS) $(ASFLAGS) $< -o $@

        # Фальшивая цель для очистки
        clean:
        	@echo "Cleaning up..."
        	rm -f $(TARGET) $(OBJECTS) # Удаляем исполняемый файл и все .o

        # Объявление фальшивых целей
        .PHONY: all clean

        ```
    *   **Объяснение:**
        *   Определяем переменные для компиляторов, флагов, исходных файлов.
        *   Используем функцию `patsubst` (pattern substitution) для автоматического получения списка объектных файлов (`.o`) из списков исходных файлов (`.c`, `.asm`).
        *   Цель `all` зависит от финального `$(TARGET)`.
        *   Правило линковки `$(TARGET)` зависит от *всех* объектных файлов (`$(OBJECTS)`). Оно использует `$^` для передачи всех `.o` файлов линковщику.
        *   Шаблонное правило `%.o: %.c` теперь включает `c_module.h` в зависимости. Это значит, что если `c_module.h` изменится, то *все* `.c` файлы, которые его включают (в данном случае `main.c` и `c_module.c`), будут перекомпилированы при следующем запуске `make`, т.к. их соответствующие `.o` файлы станут устаревшими относительно `.h` файла.
        *   Шаблонное правило для NASM остается прежним.
        *   Цель `clean` удаляет все сгенерированные файлы.
        *   `all` и `clean` объявлены как `.PHONY`.
        *   Используется `@echo` для вывода сообщений вместо самих команд.

7.  **Интеграция с курсом:**
    *   Для всех предыдущих примеров, где требовалась компиляция/сборка (Hello World C/NASM, анализ кода, проекты), можно и нужно написать `Makefile`.
    *   Это значительно упрощает пересборку после внесения изменений и обеспечивает консистентность процесса сборки.
    *   Для проектов из Главы 12 `Makefile` становится практически необходим для управления несколькими файлами и этапами сборки.

8.  **Кратко о продвинутых возможностях:**
    *   **Условия:** `#ifeq`, `#ifneq`, `#ifdef`, `#ifndef`, `#else`, `#endif`. Позволяют менять логику `Makefile` в зависимости от переменных или окружения.
      ```makefile
      ifeq ($(DEBUG), 1)
      CFLAGS += -DDEBUG_MODE -O0
      else
      CFLAGS += -O2
      endif
      ```
      Запуск: `make DEBUG=1` или просто `make`.
    *   **Функции:** `$(wildcard *.c)` (найти все `.c` файлы), `$(patsubst ...)` (замена по шаблону), `$(subst ...)` (простая замена), `$(shell команда)` (выполнить команду оболочки и подставить ее вывод).
    *   **Включение других файлов:** `include other_makefile.mk`. Позволяет разбивать большие `Makefile` на модули.

**Вывод:** `make` и `Makefile` - это стандарт де-факто для сборки проектов на C/C++ и многих других языках в Unix-подобных средах. Освоение этого инструмента существенно повышает продуктивность и надежность процесса разработки низкоуровневого ПО.

---
