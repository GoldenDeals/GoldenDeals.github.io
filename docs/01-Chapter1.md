# База Computer Sience

## Глава 1: Что такое Компьютерные Науки? Путешествие в историю.

### 1.1. Определение Computer Science

**Компьютерные Науки (Computer Science, CS)** – это не просто изучение компьютеров или программирования. Это фундаментальная научная и практическая область, изучающая **вычисления** и **информацию**. Она охватывает:

*   **Теорию вычислений:** Что в принципе можно вычислить? Каковы пределы вычислений? (Машина Тьюринга, теория сложности).
*   **Алгоритмы и структуры данных:** Как эффективно решать задачи и организовывать данные?
*   **Архитектуру компьютера:** Как устроены вычислительные машины? Как взаимодействуют их компоненты?
*   **Программную инженерию:** Как проектировать, разрабатывать, тестировать и поддерживать надежное программное обеспечение?
*   **Искусственный интеллект и машинное обучение:** Как создавать системы, способные обучаться, рассуждать и действовать автономно?
*   **Сети и распределенные системы:** Как компьютеры обмениваются информацией и работают вместе?
*   **Базы данных:** Как эффективно хранить, извлекать и управлять большими объемами информации?
*   **Графику и визуализацию:** Как создавать и отображать изображения и модели?
*   **Кибербезопасность:** Как защищать информацию и системы от угроз?
*   **Взаимодействие человека с компьютером (HCI):** Как сделать компьютеры удобными и эффективными для использования людьми?

Программирование – это важный *инструмент* в CS, но не вся дисциплина. CS отвечает на вопросы "Что?", "Почему?" и "Как?" в мире информации и вычислений.

### 1.2. Истоки: От Абака до Аналитической Машины

Стремление автоматизировать вычисления прослеживается сквозь века:

*   **Абак (Древний мир):** Простейшее счетное устройство.
*   **Антикитерский механизм (ок. 100 г. до н.э.):** Сложный механический "компьютер" для астрономических расчетов.
*   **Счетные палочки Непера (XVII век):** Упрощение умножения и деления.
*   **Логарифмическая линейка (XVII век):** Аналоговое вычислительное устройство.
*   **Арифмометр Паскаля ("Паскалина", 1642):** Механический калькулятор для сложения и вычитания.
*   **Калькулятор Лейбница (1673):** Умел также умножать, делить и извлекать корни. Лейбниц также описал двоичную систему счисления.
*   **Ткацкий станок Жаккарда (1804):** Использовал перфокарты для управления узорами ткани – идея программирования!
*   **Чарльз Бэббидж (XIX век):**
    *   **Разностная машина (Difference Engine):** Предназначена для автоматического расчета полиномиальных функций (например, для навигационных таблиц). Частично построена.
    *   **Аналитическая машина (Analytical Engine):** Проект *первого универсального программируемого компьютера*! Концепция включала:
        *   "Склад" (Store): Память для хранения чисел.
        *   "Мельница" (Mill): Арифметико-логическое устройство для операций.
        *   Управляющее устройство: Чтение инструкций с перфокарт.
        *   Устройства ввода/вывода.
        Эта машина, хоть и не была построена при жизни Бэббиджа, содержала все ключевые идеи современных компьютеров.
*   **Ада Лавлейс (XIX век):** Соратница Бэббиджа. Перевела его лекции и добавила обширные комментарии, включая алгоритм вычисления чисел Бернулли для Аналитической машины. Считается **первым программистом** в истории. Она предвидела, что машины смогут не только считать, но и создавать музыку, графику.
*   **Герман Холлерит (конец XIX века):** Создал **табулятор** на перфокартах для ускорения обработки данных переписи населения США 1890 года. Основал компанию Tabulating Machine Company, которая позже стала частью **IBM**.

### 1.3. Теоретический Прорыв: Алан Тьюринг

XX век принес математическую формализацию понятий вычисления и алгоритма. Ключевая фигура – **Алан Тьюринг**.

*   **Машина Тьюринга (1936):**
    *   Это не физическое устройство, а **абстрактная математическая модель** вычислений.
    *   **Компоненты:**
        1.  **Бесконечная лента:** Разделена на ячейки, каждая может содержать символ из конечного алфавита (или быть пустой).
        2.  **Головка чтения/записи:** Может читать символ из текущей ячейки, записывать новый символ и перемещаться на одну ячейку влево или вправо.
        3.  **Конечный набор состояний:** Машина всегда находится в одном из этих состояний. Есть специальное начальное состояние и состояния останова.
        4.  **Таблица правил (Программа):** Определяет действия машины. Для каждой комбинации (текущее состояние, символ под головкой) правило указывает: (новое состояние, символ для записи, направление движения головки).
    *   **Принцип работы:** Начинает в начальном состоянии, читает символ, по таблице правил меняет состояние, записывает символ, двигает головку. Повторяет до достижения состояния останова. Содержимое ленты в конце – результат вычислений.

*   **Универсальная Машина Тьюринга:** Тьюринг доказал существование *универсальной* машины, которая может эмулировать работу *любой* другой машины Тьюринга. Ей на ленту нужно подать описание эмулируемой машины (ее таблицу правил) и ее входные данные. Это теоретическая основа идеи **хранимой программы**.
*   **Тезис Чёрча-Тьюринга:** Неформальная гипотеза: *Любая функция, которую можно считать вычислимой с помощью алгоритма, вычислима на машине Тьюринга*. Это связывает интуитивное понятие "алгоритм" с формальной моделью.
*   **Проблема останова (Halting Problem):** Тьюринг доказал, что *не существует* общего алгоритма (машины Тьюринга), который мог бы определить для *произвольной* программы (машины Тьюринга) и ее входных данных, остановится ли эта программа когда-нибудь или будет работать вечно. Это фундаментальное ограничение возможностей вычислений.
*   **Тест Тьюринга (1950):** Мысленный эксперимент для определения, может ли машина демонстрировать "интеллектуальное" поведение, неотличимое от человеческого. Человек-судья общается (текстом) с человеком и машиной, не зная, кто есть кто. Если судья не может надежно отличить машину от человека, машина проходит тест. Стимулировал развитие **искусственного интеллекта**.
*   **Вклад в Криптоанализ:** Во время Второй мировой войны Тьюринг работал в Блетчли-парке (Британский центр дешифровки). Он сыграл решающую роль в разработке методов и машин (например, "Бомба") для взлома немецких шифров, особенно шифра машины **"Энигма"**. Это значительно повлияло на ход войны.

### 1.4. Электронная Эра и Архитектура фон Неймана

Вторая мировая война ускорила создание первых электронных компьютеров:

*   **Colossus (1943, Великобритания):** Специализированный компьютер для взлома шифра "Лоренц", использовал вакуумные лампы. Его существование долго держалось в секрете.
*   **ENIAC (Electronic Numerical Integrator and Computer, 1945, США):** Первый широко известный электронный универсальный компьютер. Огромен (весил 30 тонн), использовал ~18 000 вакуумных ламп. Программировался перекоммутацией проводов и установкой переключателей – очень трудоемко.
*   **Архитектура фон Неймана (ок. 1945):** Описана Джоном фон Нейманом (на основе идей проекта EDVAC). Ключевые принципы, лежащие в основе большинства современных компьютеров:
    1.  **Принцип хранимой программы:** И **инструкции** (программа), и **данные** хранятся в **одной и той же памяти** (могут быть представлены в двоичном виде).
    2.  **Адресуемая память:** Память состоит из ячеек, каждая имеет уникальный номер (адрес).
    3.  **Последовательное выполнение:** Инструкции выполняются одна за другой, если нет специальной команды перехода.
    4.  **Основные компоненты:** Центральное процессорное устройство (ЦПУ/CPU), включающее арифметико-логическое устройство (АЛУ/ALU) и устройство управления (УУ/CU); основная память (ОЗУ/RAM); устройства ввода/вывода (I/O). Компоненты связаны **системной шиной**.


### 1.5. Поколения Компьютеров

Эволюцию компьютеров принято делить на поколения по ключевой элементной базе:

1.  **Первое поколение (1940-е – середина 1950-х):**
    *   **Элементная база:** Вакуумные лампы.
    *   **Характеристики:** Громоздкие, дорогие, потребляли много энергии, сильно грелись, низкая надежность (лампы часто перегорали). Низкое быстродействие (тысячи операций в секунду).
    *   **Память:** Магнитные барабаны, линии задержки.
    *   **Программирование:** Машинные коды, позже – ассемблеры.
    *   **Примеры:** ENIAC, UNIVAC I (первый коммерчески успешный), МЭСМ (СССР).
2.  **Второе поколение (середина 1950-х – середина 1960-х):**
    *   **Элементная база:** Транзисторы.
    *   **Характеристики:** Значительно меньше, дешевле, надежнее, энергоэффективнее и быстрее (десятки, сотни тысяч операций в секунду). Выделяли меньше тепла.
    *   **Память:** Магнитные сердечники, магнитные ленты и диски.
    *   **Программирование:** Появились первые **языки высокого уровня** (FORTRAN, COBOL, ALGOL), компиляторы. Зарождение операционных систем (пакетная обработка).
    *   **Примеры:** IBM 7090/7094, БЭСМ-6 (СССР).
3.  **Третье поколение (середина 1960-х – 1970-е):**
    *   **Элементная база:** Интегральные схемы (ИС, чипы) – сотни транзисторов на одном кристалле кремния.
    *   **Характеристики:** Еще большая миниатюризация, удешевление, рост производительности (миллионы операций в секунду) и надежности. Появилось понятие **семейства совместимых машин** (например, IBM System/360).
    *   **Память:** Полупроводниковая память (на ИС).
    *   **Программирование:** Развитие операционных систем (многозадачность, разделение времени), языков программирования (Pascal, C).
    *   **Примеры:** IBM System/360, DEC PDP-11.
4.  **Четвертое поколение (1970-е – наши дни):**
    *   **Элементная база:** Большие (LSI) и сверхбольшие (VLSI) интегральные схемы – тысячи, миллионы, а теперь и миллиарды транзисторов на чипе. Появление **микропроцессора** (весь ЦП на одном чипе, Intel 4004 - 1971 г.).
    *   **Характеристики:** **Революция персональных компьютеров (ПК)**. Резкое снижение размеров и стоимости. Рост производительности продолжается (закон Мура). Развитие сетей (Internet), графических интерфейсов (GUI), мобильных устройств.
    *   **Примеры:** Персональные компьютеры (Altair 8800, Apple II, IBM PC), современные ПК, ноутбуки, смартфоны, серверы.
5.  **(Возможно) Пятое поколение (будущее?):** Часто связывают с искусственным интеллектом, параллельными вычислениями, квантовыми компьютерами, нейронными сетями. Четких границ нет.


## Глава 2: Язык Машин: Математические основы информатики.

Чтобы понимать, как компьютеры обрабатывают информацию, нам нужно освоить их "родной язык". В его основе лежат простые, но мощные математические концепции: системы счисления и булева алгебра.

### 2.1. Системы Счисления

Система счисления – это способ записи чисел с помощью набора символов (цифр). Мы привыкли к десятичной системе, но компьютеры используют двоичную.

*   **Позиционные Системы:** Значение цифры зависит от ее **позиции** (разряда) в числе. Общий вид числа в системе с основанием b:
    $$ (d_n d_{n-1} \dots d_1 d_0)_b = \sum_{i=0}^{n} d_i \cdot b^i $$
    где $d_i$ – цифра в $i$-й позиции, $b$ – основание системы.

*   **Десятичная (Decimal, основание 10):**
    *   Цифры: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9.
    *   Пример: $$ (123)_{10} = 1 \cdot 10^2 + 2 \cdot 10^1 + 3 \cdot 10^0 $$

*   **Двоичная (Binary, основание 2):**
    *   Цифры: 0, 1. Основа работы цифровой электроники (вкл/выкл, есть ток/нет тока).
    *   Минимальная единица информации – **бит** (binary digit).
    *   Пример: $$ (1101)_2 = 1 \cdot 2^3 + 1 \cdot 2^2 + 0 \cdot 2^1 + 1 \cdot 2^0  $$
        $$ = 1 \cdot 8 + 1 \cdot 4 + 0 \cdot 2 + 1 \cdot 1 = 8 + 4 + 1 = (14)_{10} $$

*   **Шестнадцатеричная (Hexadecimal, Hex, основание 16):**
    *   Цифры: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A (10), B (11), C (12), D (13), E (14), F (15).
    *   Используется для **компактной записи** двоичных чисел, т.к. $16 = 2^4$, одна hex-цифра точно соответствует 4 битам (**нибблу** или **полубайту**). Удобна для представления адресов памяти, кодов цветов (RGB), машинных инструкций.
    *   Пример: $$ (2AF)_{16} = 2 \cdot 16^2 + 10 \cdot 16^1 + 15 \cdot 16^0 = \dots$$

**Преобразования между системами:**

1.  **Из любой системы в десятичную:** Использовать формулу позиционной системы (как в примерах выше).
2.  **Из десятичной в двоичную (целая часть):** Последовательно делить число на 2 и записывать остатки в **обратном** порядке.
    *   Пример: Преобразовать $(25)_{10}$ в двоичную:
        *   25 / 2 = 12 (остаток **1**)
        *   12 / 2 = 6  (остаток **0**)
        *   6  / 2 = 3  (остаток **0**)
        *   3  / 2 = 1  (остаток **1**)
        *   1  / 2 = 0  (остаток **1**)
        *   Результат (читаем остатки снизу вверх): $ (11001)_2 $
3.  **Из десятичной в шестнадцатеричную (целая часть):** Аналогично, делить на 16, остатки > 9 заменять на A-F.
    *   Пример: Преобразовать $(687)_{10}$ в шестнадцатеричную:
        *   687 / 16 = 42 (остаток **15** -> **F**)
        *   42 / 16 = 2  (остаток **10** -> **A**)
        *   2  / 16 = 0  (остаток **2**)
        *   Результат (снизу вверх): $ (2AF)_{16} $

**Двоичная арифметика (сложение):**
Правила простые:
$$ 0 + 0 = 0 $$
$$ 0 + 1 = 1 $$
$$ 1 + 0 = 1 $$
$$ 1 + 1 = 0 $$ (и **1** переносится в следующий разряд)
$$ 1 + 1 + 1 = 1 $$ (и **1** переносится в следующий разряд)

Пример: $ (1101)_2 + (1011)_2 $
```
   1 1 1   <-- переносы
   1101   (13_10)
+  1011   (11_10)
-------
  11000   (24_10)
```

### 2.2. Булева Алгебра (Алгебра Логики)

Основа цифровой логики. Оперирует двумя значениями: **Истина (True, 1)** и **Ложь (False, 0)**.

**Основные операции:**

1.  **Логическое И (Конъюнкция, AND, $ \land $, `&`):**
    *   Результат `True` только если **оба** операнда `True`.
    *   $ A \land B $
2.  **Логическое ИЛИ (Дизъюнкция, OR, $ \lor $, `|`):**
    *   Результат `True` если **хотя бы один** операнд `True`.
    *   $ A \lor B $
3.  **Логическое НЕ (Отрицание, Инверсия, NOT, $ \neg $, `!`, `~`):**
    *   Меняет значение операнда на противоположное.
    *   $ \neg A $

Вы будете их использовать ОЧЕНЬ часто

**Таблицы истинности:** Показывают результат операции для всех комбинаций входов.

| A | B | $A \land B$ | $A \lor B$ |
|---|---|:-----------:|:----------:|
| 0 | 0 |      0      |     0      |
| 0 | 1 |      0      |     1      |
| 1 | 0 |      0      |     1      |
| 1 | 1 |      1      |     1      |

| A | $\neg A$ |
|---|:--------:|
| 0 |     1    |
| 1 |     0    |

**Другие важные операции:**

*   **Исключающее ИЛИ (XOR, $ \oplus $):** Результат `True` если **ровно один** из операндов `True`.
    $ A \oplus B = (A \land \neg B) \lor (\neg A \land B) $
    | A | B | $$A \oplus B$$ |
    |---|---|:------------:|
    | 0 | 0 |      0       |
    | 0 | 1 |      1       |
    | 1 | 0 |      1       |
    | 1 | 1 |      0       |

**Логические выражения:** Комбинации переменных и операций, например: $ F = (A \lor B) \land (\neg C) $

**Законы Булевой Алгебры:** Позволяют упрощать выражения.
*   **Коммутативность:** $ A \lor B = B \lor A $ или $ A \land B = B \land A $
*   **Ассоциативность:** $ (A \lor B) \lor C = A \lor (B \lor C) $ или $ (A \land B) \land C = A \land (B \land C) $
*   **Дистрибутивность:** $ A \land (B \lor C) = (A \land B) \lor (A \land C) $ или $ A \lor (B \land C) = (A \lor B) \land (A \lor C) $
*   **Законы Идемпотентности:** $ A \lor A = A $ или $ A \land A = A $
*   **Законы Поглощения:** $ A \lor (A \land B) = A $ или $ A \land (A \lor B) = A $
*   **Законы де Моргана:**
    *   $ \neg (A \land B) = (\neg A) \lor (\neg B) $ (НЕ от И есть ИЛИ от НЕ)
    *   $ \neg (A \lor B) = (\neg A) \land (\neg B) $ (НЕ от ИЛИ есть И от НЕ)
*   **Двойное отрицание:** $ \neg (\neg A) = A $
*   **Операции с константами (0 - Ложь, 1 - Истина):**
    *   $ A \lor 0 = A $, $ A \land 1 = A $ (Нейтральные элементы)
    *   $ A \lor 1 = 1 $, $ A \land 0 = 0 $ (Доминирующие элементы)
    *   $ A \lor \neg A = 1 $ (Закон исключенного третьего)
    *   $ A \land \neg A = 0 $ (Закон противоречия)

**Пример упрощения:** 
Упростить $ F = (A \lor B) \land (A \lor \neg B) $
Используем дистрибутивность (вторую форму): $ F = A \lor (B \land \neg B) $
По закону противоречия: $ B \land \neg B = 0 $ => $ F = A \lor 0 $
По закону с константой: $ F = A $

Булева алгебра – основа проектирования **логических вентилей** (AND, OR, NOT и т.д.), из которых строятся все цифровые схемы компьютера.

### 2.3. Представление Данных в Компьютере

Вся информация (числа, текст, изображения, звук) хранится и обрабатывается в виде **битов**.

*   **Целые числа (Integers):**
    *   **Беззнаковые (Unsigned):** Все биты используются для представления величины числа. Диапазон для N бит: от 0 до $2^N - 1$.
        *   Пример (8 бит): от 0 до $2^8 - 1 = 255$. $ (11111111)_2 = 255_{10} $.
    *   **Знаковые (Signed):** Нужно представлять и положительные, и отрицательные числа.
        *   *Прямой код (Sign-Magnitude):* Один бит (обычно старший) используется для знака (0 - плюс, 1 - минус), остальные – для величины. Прост для понимания, но имеет два нуля (+0 и -0) и сложную арифметику.
        *   *Обратный код (One's Complement):* Отрицательное число получается инвертированием всех битов положительного. Тоже имеет два нуля.
        *   **Дополнительный код (Two's Complement):** Наиболее распространенный способ. Отрицательное число $-X$ получается инвертированием всех битов положительного числа $X$ и **прибавлением 1** к результату.
            *   **Преимущества:** Только один ноль, сложение и вычитание выполняются одной и той же операцией сложения (вычитание A - B эквивалентно A + (-B) в доп. коде).
            *   Диапазон для N бит: от $-(2^{N-1})$ до $+(2^{N-1} - 1)$.
            *   Пример (8 бит): Диапазон от -128 до +127.
                *   $ +5_{10} = (00000101)_2 $
                *   Найти $ -5_{10} $:
                    1.  Инвертируем биты +5: $ (11111010)_2 $
                    2.  Прибавляем 1: $ (11111011)_2 $ (Это и есть -5 в доп. коде)
                *   Старший бит (1) указывает на отрицательное число.

*   **Вещественные числа (Floating-Point):** Представление чисел с дробной частью и очень больших/малых чисел.
    *   **Стандарт IEEE 754:** Наиболее распространенный формат. Число представляется в виде:
        $$ \text{Число} = \text{Знак} \times \text{Мантисса} \times \text{Основание}^{\text{Порядок}} $$
        (Основание обычно 2).
    *   В памяти хранятся три части:
        *   **Знак (Sign):** 1 бит (0 - плюс, 1 - минус).
        *   **Порядок (Exponent):** Целое число со смещением (чтобы хранить и положительные, и отрицательные степени).
        *   **Мантисса (Mantissa / Significand):** Дробная часть числа в нормализованном виде (обычно вида 1.xxxxx...). Первая единица часто не хранится (скрытый бит) для экономии места.
    *   **Форматы:**
        *   *Одинарная точность (Single Precision, `float`):* 32 бита (1 знак, 8 порядок, 23 мантисса).
        *   *Двойная точность (Double Precision, `double`):* 64 бита (1 знак, 11 порядок, 52 мантисса).
    *   **Особенности:** Не все десятичные дроби точно представимы в двоичном формате. Могут возникать ошибки округления. Есть специальные значения: `NaN` (Not a Number), `+Infinity`, `-Infinity`.

*   **Символы (Characters):** Каждому символу ставится в соответствие уникальный числовой код.
    *   **ASCII (American Standard Code for Information Interchange):** Старая 7-битная кодировка (128 символов: латинские буквы, цифры, знаки препинания, управляющие символы). Позже расширена до 8 бит (256 символов) для поддержки национальных символов (но разные "кодовые страницы" были несовместимы).
        *   Пример: 'A' = 65 = $(41)_{16}$, 'a' = 97 = $(61)_{16}$, '0' = 48 = $(30)_{16}$.
    *   **Unicode:** Современный стандарт, цель которого – закодировать **все** символы **всех** письменных языков мира. Содержит более 140 000 символов.
    *   **UTF-8 (Unicode Transformation Format - 8-bit):** Самая популярная кодировка Unicode (особенно в вебе). Использует **переменное количество байт** для кодирования символов:
        *   Символы ASCII (0-127) кодируются 1 байтом (так же, как в ASCII).
        *   Другие символы Unicode кодируются 2, 3 или 4 байтами.
        *   **Преимущества:** Обратная совместимость с ASCII, эффективность для текстов на основе латиницы, нет проблем с порядком байт.


Вот что можно прочитать: 

НЕ надо читать от корки до корки (тут есть учебник на 280 страниц) - просто посмотрите и углубитесь в темы, которые остались не понятны 

[История компьютерных наук](https://en.wikipedia.org/wiki/History_of_computer_science)

[Конспект "История и методология компьютерных наук"](https://is.ifmo.ru/books/2016/Odinets-Computer-History-Lectures.pdf)

[Computer Science: книги, от новичка до профи](https://habr.com/ru/articles/774746/)

[Книга: Теоретический минимум по Computer Science](https://raw.githubusercontent.com/GoldenDeals/GoldenDeals.github.io/refs/heads/main/assets/termin-cs.pdf)

[Хабр Основы систем счисления](https://habr.com/ru/articles/124395/)

[О системах счисления](https://en.wikipedia.org/wiki/Numeral_system)

[О позиционных СС](https://en.wikipedia.org/wiki/Positional_notation)

[О матемаческой логике](https://en.wikipedia.org/wiki/Mathematical_logic)

[Еще про логику](https://www.geeksforgeeks.org/introduction-to-mathematical-logic/)

[И еще про логику](http://mathprofi.ru/osnovy_matematicheskoj_logiki.html)

[Учебник "Математическая логика и теория алгоритмов"](https://elar.urfu.ru/bitstream/10995/1601/4/1334887_schoolbook.pdf)

[Логические операции](https://zftsh.online/articles/4727)

[О арифметике](https://book.kbsu.ru/theory/chapter4/1_4_10.html)

[О числах с плавающей запятой](https://en.wikipedia.org/wiki/IEEE_754)

[Таблица ASCII](https://www.ascii-code.com/)

[О UTF-8](https://en.wikipedia.org/wiki/UTF-8)

